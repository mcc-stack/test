(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{376:function(_,v,t){_.exports=t.p+"assets/img/image-20200211185156724.27b0ed29.png"},377:function(_,v,t){_.exports=t.p+"assets/img/image-20200229205226968.e2d73446.png"},378:function(_,v,t){_.exports=t.p+"assets/img/image-20200229205311421.09aca2c6.png"},379:function(_,v,t){_.exports=t.p+"assets/img/image-20200229205247818.8c67bcf1.png"},380:function(_,v,t){_.exports=t.p+"assets/img/image-20200229205335851.ebfc194a.png"},381:function(_,v,t){_.exports=t.p+"assets/img/image-20200211190831559.8042b8e4.png"},382:function(_,v,t){_.exports=t.p+"assets/img/image-20200211194653599.e23fe2f0.png"},383:function(_,v,t){_.exports=t.p+"assets/img/image-20200229200430528.7e84008d.png"},384:function(_,v,t){_.exports=t.p+"assets/img/image-20200229200751442.b1455d26.png"},385:function(_,v,t){_.exports=t.p+"assets/img/image-20200229201207993.2b01a367.png"},386:function(_,v,t){_.exports=t.p+"assets/img/image-20200211191040778.236d0b3e.png"},387:function(_,v,t){_.exports=t.p+"assets/img/image-20200211191437556.3f96b63e.png"},388:function(_,v,t){_.exports=t.p+"assets/img/image-20200211202558767.52eada6e.png"},389:function(_,v,t){_.exports=t.p+"assets/img/image-20200211212636712.97821e8d.png"},390:function(_,v,t){_.exports=t.p+"assets/img/image-20200229215736657.620167c8.png"},391:function(_,v,t){_.exports=t.p+"assets/img/image-20200308153027902.f25d020d.png"},392:function(_,v,t){_.exports=t.p+"assets/img/image-20200308153052652.f94f4a45.png"},422:function(_,v,t){"use strict";t.r(v);var s=t(42),a=Object(s.a)({},(function(){var _=this,v=_.$createElement,s=_._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[s("h1",{attrs:{id:"计算机网络"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计算机网络"}},[_._v("#")]),_._v(" 计算机网络")]),_._v(" "),s("h2",{attrs:{id:"网络模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网络模型"}},[_._v("#")]),_._v(" 网络模型")]),_._v(" "),s("p",[s("img",{attrs:{src:t(376),alt:"image-20200211185156724"}})]),_._v(" "),s("h2",{attrs:{id:"协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协议"}},[_._v("#")]),_._v(" 协议")]),_._v(" "),s("h3",{attrs:{id:"应用层协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用层协议"}},[_._v("#")]),_._v(" 应用层协议")]),_._v(" "),s("p",[_._v("SMTP 协议：提供可靠且有效的电子邮件传输的协议，端口为 25。")]),_._v(" "),s("p",[_._v("FTP 协议：TCP/IP 网络上两台计算机传送文件的协议，默认情况下 FTP 协议使用 TCP 端口中的 20 和 21 这两个端口，其中 20 用于传输数据，21 用于传输控制信息。")]),_._v(" "),s("h3",{attrs:{id:"传输层协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#传输层协议"}},[_._v("#")]),_._v(" 传输层协议")]),_._v(" "),s("p",[_._v("telnet 协议：用于远程登录，端口号为 23。")]),_._v(" "),s("h3",{attrs:{id:"网络层协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网络层协议"}},[_._v("#")]),_._v(" 网络层协议")]),_._v(" "),s("p",[_._v("ARP 协议：根据 IP 地址获取物理地址的一个 TCP/IP 协议。")]),_._v(" "),s("p",[_._v("ICMP 协议：它是 TCP/IP 协议族的一个子协议，用于在"),s("strong",[_._v("IP 主机")]),_._v("、"),s("strong",[_._v("路由器")]),_._v("之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。其中,"),s("strong",[_._v("PING")]),_._v("命令的实现原理就是：Ping 发送一个 ICMP ECHO 包，接受 ICMP echo（ICMP 回声应答）。")]),_._v(" "),s("h2",{attrs:{id:"http-协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-协议"}},[_._v("#")]),_._v(" HTTP 协议")]),_._v(" "),s("p",[_._v("超文本传输协议，HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端，位于应用层，并且是无状态的一种协议。")]),_._v(" "),s("h3",{attrs:{id:"请求协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请求协议"}},[_._v("#")]),_._v(" 请求协议")]),_._v(" "),s("p",[s("img",{attrs:{src:t(377),alt:"image-20200229205226968"}})]),_._v(" "),s("p",[s("img",{attrs:{src:t(378),alt:"image-20200229205311421"}})]),_._v(" "),s("h3",{attrs:{id:"响应协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#响应协议"}},[_._v("#")]),_._v(" 响应协议")]),_._v(" "),s("p",[s("img",{attrs:{src:t(379),alt:"image-20200229205247818"}})]),_._v(" "),s("p",[s("img",{attrs:{src:t(380),alt:"image-20200229205335851"}})]),_._v(" "),s("h3",{attrs:{id:"http-请求方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-请求方法"}},[_._v("#")]),_._v(" Http 请求方法")]),_._v(" "),s("ul",[s("li",[s("p",[_._v("GET")]),_._v(" "),s("p",[_._v("向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访问。")])]),_._v(" "),s("li",[s("p",[_._v("POST")]),_._v(" "),s("p",[_._v("向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。")])]),_._v(" "),s("li",[s("p",[_._v("HEAD")]),_._v(" "),s("p",[_._v("与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。")])]),_._v(" "),s("li",[s("p",[_._v("PUT")]),_._v(" "),s("p",[_._v("向指定资源位置上传其最新内容。")])]),_._v(" "),s("li",[s("p",[_._v("DELETE")]),_._v(" "),s("p",[_._v("请求服务器删除 Request-URI 所标识的资源。")])]),_._v(" "),s("li",[s("p",[_._v("TRACE")]),_._v(" "),s("p",[_._v("回显服务器收到的请求，主要用于测试或诊断。")])]),_._v(" "),s("li",[s("p",[_._v("OPTIONS")]),_._v(" "),s("p",[_._v("这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用'*'来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。")])]),_._v(" "),s("li",[s("p",[_._v("CONNECT")]),_._v(" "),s("p",[_._v("HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。通常用于 SSL 加密服务器的链接（经由非加密的 HTTP 代理服务器）。")])])]),_._v(" "),s("h3",{attrs:{id:"get-和-post-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#get-和-post-的区别"}},[_._v("#")]),_._v(" GET 和 POST 的区别")]),_._v(" "),s("ul",[s("li",[_._v("GET 提交的数据会放在 URL 之后，也就是请求行里面，以?分割 URL 和传输数据，参数之间以&相连，如 EditBook?name=test1&id=123456；POST 方法是把提交的数据放在 HTTP 包的请求体中。")]),_._v(" "),s("li",[_._v("GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制。")]),_._v(" "),s("li",[_._v("GET 是不安全的，而 POST 是安全的。")])]),_._v(" "),s("h2",{attrs:{id:"tcp-协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-协议"}},[_._v("#")]),_._v(" TCP 协议")]),_._v(" "),s("p",[_._v("TCP 协议的主要功能是完成对数据报的确认、流量控制和网络拥塞;自动检测数据报，并提供错误重发的功能;将多条路径传送的数据报按照原来的顺序进行排列，并对重复数据进行择取;控制超时重发，自动调整超时值;提供自动恢复丢失数据的功能。")]),_._v(" "),s("p",[s("img",{attrs:{src:t(381),alt:"image-20200211190831559"}})]),_._v(" "),s("ol",[s("li",[_._v("URG: 表示紧急指针是否有效。")]),_._v(" "),s("li",[_._v("ACK: 表示确认号是否有效(携带 ACK 标志的 TCP 报文段称为确认报文段)。")]),_._v(" "),s("li",[_._v("PSH: 提示接收端应用程序要立即从 TCP 接收缓冲区读走数据，以腾出空间接收后续的数据。(若应用 程序不读走数据，数据会一直留在 TCP 模块的接收缓冲区)。")]),_._v(" "),s("li",[_._v("RST: 表示要求对方重新建立连接(携带 RST 标志的 TCP 报文段为复位报文段)。")]),_._v(" "),s("li",[_._v("SYN: 表示请求建立一个连接(携带 SYN 标志的 TCP 报文段称为同步报文段)。")]),_._v(" "),s("li",[_._v("FIN: 表示通知对方要关闭连接(携带 FIN 标志的 TCP 报文段为结束报文段)。")])]),_._v(" "),s("h2",{attrs:{id:"tcp-协议如何保证传输可靠性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-协议如何保证传输可靠性"}},[_._v("#")]),_._v(" TCP 协议如何保证传输可靠性")]),_._v(" "),s("ul",[s("li",[_._v("数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；")]),_._v(" "),s("li",[_._v("对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；")]),_._v(" "),s("li",[_._v("丢弃重复数据：对于重复数据，能够丢弃重复数据；")]),_._v(" "),s("li",[_._v("应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；")]),_._v(" "),s("li",[_._v("超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；")]),_._v(" "),s("li",[_._v("流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。")])]),_._v(" "),s("h2",{attrs:{id:"udp-协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#udp-协议"}},[_._v("#")]),_._v(" UDP 协议")]),_._v(" "),s("p",[s("img",{attrs:{src:t(382),alt:"image-20200211194653599"}})]),_._v(" "),s("p",[_._v("与 TCP 协议的区别：")]),_._v(" "),s("table",[s("thead",[s("tr",[s("th"),_._v(" "),s("th",[_._v("UDP")]),_._v(" "),s("th",[_._v("TCP")])])]),_._v(" "),s("tbody",[s("tr",[s("td",[_._v("是否连接")]),_._v(" "),s("td",[_._v("无连接")]),_._v(" "),s("td",[_._v("面向连接")])]),_._v(" "),s("tr",[s("td",[_._v("是否可靠")]),_._v(" "),s("td",[_._v("不可靠传输")]),_._v(" "),s("td",[_._v("可靠传输，使用流量控制和拥塞控制")])]),_._v(" "),s("tr",[s("td",[_._v("连接对象个数")]),_._v(" "),s("td",[_._v("支持一对一，一对多，多对一和多对多交互通信")]),_._v(" "),s("td",[_._v("只能是一对一通信")])]),_._v(" "),s("tr",[s("td",[_._v("传输方式")]),_._v(" "),s("td",[_._v("面向报文")]),_._v(" "),s("td",[_._v("面向字节流")])]),_._v(" "),s("tr",[s("td",[_._v("首部开销")]),_._v(" "),s("td",[_._v("首部开销小，仅 8 字节")]),_._v(" "),s("td",[_._v("首部最小 20 字节，最大 60 字节")])]),_._v(" "),s("tr",[s("td",[_._v("适用场景")]),_._v(" "),s("td",[_._v("适用于实时应用（QQ、IP 电话、视频会议、直播等）")]),_._v(" "),s("td",[_._v("适用于要求可靠传输的应用，例如文件传输")])])])]),_._v(" "),s("h2",{attrs:{id:"ip-协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ip-协议"}},[_._v("#")]),_._v(" IP 协议")]),_._v(" "),s("p",[_._v("IP 协议为网络层协议，主要是在相互连接的网络之间传递 IP 数据报，主要功能有两方面，分别是寻址与路由和分段与重组，而在 IP 协议当中，最重要的就是 TTL（IP 允许通过的最大网段数量）字段（八位），规定该数据包能穿过几个路由之后才会被抛弃。IP 报文如下所示：")]),_._v(" "),s("p",[s("img",{attrs:{src:t(383),alt:"image-20200229200430528"}})]),_._v(" "),s("ul",[s("li",[s("p",[_._v("4 位版本号：表示 IP 协议的版本，IPV4 的值 0100，IPV6 的值 0110；")])]),_._v(" "),s("li",[s("p",[_._v("4 位首部长度：指的是 IP 包头部的长度，最大值是 15，即 15 * 32 / 8 = 60 个字节，所以选项部分的最大值是 40 个字节；")])]),_._v(" "),s("li",[s("p",[_._v("8 位服务类型：前 3 位表示优先级、后 4 位是标志位、最后一位保留未用；")])]),_._v(" "),s("li",[s("p",[_._v("16 位总长度：指的是 IP 包的总长度，最大长度是 65535 个字节。在以太网上允许的最长包长为 1500B，所以当 IP 包过大时会进行分片传输；")])]),_._v(" "),s("li",[s("p",[_._v("16 位标识符：用于数据在分段传输时标识其序列号；（每从上层接收到一个数据报时，就将内置的一个累加器加 1，并将其值赋值到标识符字段）")])]),_._v(" "),s("li",[s("p",[_._v("3 位标志：三位从左到右分别为 MF、DF、未用。MF=0 表示没有更多的分片；DF=1 表示路由器不能对改数据包分段；（如果 IP 报文过大时，会存在同一个 IP 数据报文被分片的情况）")])]),_._v(" "),s("li",[s("p",[_._v("13 位片偏移：也称为段偏移，用于标识数据包在上层初始数据报文中的偏移量；（如果同一个 IP 数据包本分片后，通过片偏移就可以知道分片的相对位置）")])]),_._v(" "),s("li",[s("p",[_._v("8 位生存时间：初始值由操作系统设置，每经过一个路由器转发后其值都会建议，如果其值等于 0 后还没有到达目的地，就行丢弃该数据包；")])]),_._v(" "),s("li",[s("p",[_._v("8 位协议：标识上层所使用的协议；")])]),_._v(" "),s("li",[s("p",[_._v("16 位首部校验和：只对 IP 数据包的首部进行校验，不包含数据部分；")])]),_._v(" "),s("li",[s("p",[_._v("32 位源 IP 地址：标识数据从哪里来；")])]),_._v(" "),s("li",[s("p",[_._v("32 位目的 IP：标识数据到哪里去；")])]),_._v(" "),s("li",[s("p",[_._v("选项部分：主要有安全和处理限制、记录路径、时间戳等。")])])]),_._v(" "),s("h2",{attrs:{id:"以太网帧"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#以太网帧"}},[_._v("#")]),_._v(" 以太网帧")]),_._v(" "),s("p",[_._v("在数据链路层中，使用最多的就是以太网，而以太网帧因为历史原因存在多个版本，这里采用 IEEE 802.3 以太帧格式。")]),_._v(" "),s("p",[s("img",{attrs:{src:t(384),alt:"image-20200229200751442"}})]),_._v(" "),s("ul",[s("li",[s("p",[_._v("前导码：7 个字节，用于数据传输过程中的双方发送与接收的速率的同步。")])]),_._v(" "),s("li",[s("p",[_._v("SFD：帧开始符，1 个字节，用于标识一个以太网帧的开始。")])]),_._v(" "),s("li",[s("p",[_._v("目的 MAC 地址：6 个字节，指明帧的接收者。")])]),_._v(" "),s("li",[s("p",[_._v("源 MAC 地址：6 个字节，指明帧的发送者。")])]),_._v(" "),s("li",[s("p",[_._v("长度：2 个字节，指明该帧数据字段的长度，但不代表数据字段长度能够达到 2^16 字节。")])]),_._v(" "),s("li",[s("p",[_._v("类型：2 个字节，指明帧中数据的协议类型，比如常见的 IPv4 中的 ip 协议采用 0x0800。")])]),_._v(" "),s("li",[s("p",[_._v("数据与填充：46~1500 个字节，包含了上层协议传递下来的数据，如果加入数据字段后帧长度不够 64 字节，会在数据字段加入填充字段达到 64 字节。")])]),_._v(" "),s("li",[s("p",[_._v("校验和：4 个字节，对接收网卡(主要是检测数据与填充字段)提供判断是否传输错误的一种方法，如果发现错误，则丢弃此帧。目前最为流行的用于校验和(FCS)的算法是循环冗余校验(cyclic redundancy check -- CRC)。")])])]),_._v(" "),s("h2",{attrs:{id:"数据包的封装和解封过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据包的封装和解封过程"}},[_._v("#")]),_._v(" 数据包的封装和解封过程")]),_._v(" "),s("p",[s("img",{attrs:{src:t(385),alt:"image-20200229201207993"}})]),_._v(" "),s("h2",{attrs:{id:"三次握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[_._v("#")]),_._v(" 三次握手")]),_._v(" "),s("p",[s("img",{attrs:{src:t(386),alt:"image-20200211191040778"}})]),_._v(" "),s("p",[_._v("第一次握手：建立连接时，客户端发送 syn 包（syn=x）到服务器，并进入 SYN_SENT 状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。")]),_._v(" "),s("p",[_._v("第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=x+1），同时自己也发送一个 SYN 包（syn=y），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；")]),_._v(" "),s("p",[_._v("第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=y+1），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP 连接成功）状态，完成三次握手。")]),_._v(" "),s("h2",{attrs:{id:"四次挥手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[_._v("#")]),_._v(" 四次挥手")]),_._v(" "),s("p",[s("img",{attrs:{src:t(387),alt:"image-20200211191437556"}})]),_._v(" "),s("ol",[s("li",[_._v("客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为 seq=u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。")]),_._v(" "),s("li",[_._v("服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。")]),_._v(" "),s("li",[_._v("客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。")]),_._v(" "),s("li",[_._v("服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。")]),_._v(" "),s("li",[_._v("客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态")]),_._v(" "),s("li",[_._v("服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。")])]),_._v(" "),s("blockquote",[s("p",[_._v("问题")]),_._v(" "),s("ol",[s("li",[s("p",[_._v("为什么连接需要三次握手，而挥手需要四次？")]),_._v(" "),s("p",[_._v('答：当 Server 端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉 Client 端，"你发的 FIN 报文我收到了"。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。')])]),_._v(" "),s("li",[s("p",[_._v("为什么 TIME_WAIT 状态需要经过 2MSL(最大报文段生存时间)才能返回到 CLOSE 状态？")]),_._v(" "),s("p",[_._v("答：我们必须认为网络是不可靠的，最后一个 ACK 有可能会丢失，Server 如果没有收到 ACK，将不断重复发送 FIN 片段，所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。")])]),_._v(" "),s("li",[s("p",[_._v("为什么不能两次握手？")]),_._v(" "),s("p",[_._v("答：网络传输可能延迟，如果只使用两次握手，无法确保数据完整，有序，还会造成不必要的开销。")])]),_._v(" "),s("li",[s("p",[_._v("怎么查看 time_wait 连接数？以及怎么解决 time_wait 过多的现象？")]),_._v(" "),s("p",[_._v("答：netstat -an |grep TIME_WAIT|wc -l 。在"),s("strong",[_._v("高并发短连接")]),_._v("的 TCP 服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量 socket 处于 TIME_WAIT 状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。可以修改/etc/sysctl.conf 文件，使 TIME_WAIT 重用和快速回收。")])]),_._v(" "),s("li",[s("p",[_._v("第三次握手失败会怎么样？")]),_._v(" "),s("p",[_._v("不会重传 ack，而是直接发送 RTS 报文段，进入 CLOSED 状态，这样做可以有效避免 SYN 洪泛攻击。所谓的洪泛攻击是指伪造 IP 对被攻击端进行请求，被攻击端的响应报文无法到达，使资源很快耗尽。")])])])]),_._v(" "),s("h2",{attrs:{id:"http1-0、http1-1-和-http2-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http1-0、http1-1-和-http2-0"}},[_._v("#")]),_._v(" HTTP1.0、HTTP1.1 和 HTTP2.0")]),_._v(" "),s("h3",{attrs:{id:"http1-0-和-http1-1"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http1-0-和-http1-1"}},[_._v("#")]),_._v(" HTTP1.0 和 HTTP1.1")]),_._v(" "),s("ul",[s("li",[s("p",[s("strong",[_._v("长连接")])]),_._v(" "),s("p",[_._v("HTTP1.1 开始支持长连接。Keep—Alive 允许在一定时间内，同一个域名多次请求数据，只建立一次 http 连接，其他请求可以复用这个连接通道，以达到提高请求效率的目的。")])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("节约带宽")])]),_._v(" "),s("p",[_._v("HTTP1.1 支持只发送 header 信息。")])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("HOST 域")])]),_._v(" "),s("p",[_._v("HTTP1.1 必须要求传输 HOST 域。")])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("缓存处理")])]),_._v(" "),s("p",[_._v("HTTP1.1 引入了更多的缓存控制策略。")])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("错误通知的管理")])]),_._v(" "),s("p",[_._v("在 HTTP1.1 中新增了 24 个错误状态响应码。")])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("新增管道机制")])]),_._v(" "),s("p",[_._v("如果浏览器要向一个域名发送多个请求，需要在本地维护一个 FIFO 队列，完成了一个再发送下一个，这样就存在一个问题，服务端从完成一个请求开始回传，到收到下一个请求的这段时间内是处于空闲状态的。而管道机制可以将浏览器的请求一次性全部发给服务器，服务器可以连续处理，就不存在空闲状态。")]),_._v(" "),s("blockquote",[s("p",[_._v("存在的问题")]),_._v(" "),s("ol",[s("li",[_._v("如果第一个请求处理特别慢，将会造成阻塞，称之为队首阻塞。")]),_._v(" "),s("li",[_._v("服务端为了保证顺序回传，通常需要缓存多个响应，从而占用更多服务器资源，也更容易被攻击。")]),_._v(" "),s("li",[_._v("如果处理过程中网络异常，可能得全部重复处理。")]),_._v(" "),s("li",[_._v("一些中间代理设备不一定支持管道。")])])])])]),_._v(" "),s("h3",{attrs:{id:"http1-1-和-http2-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http1-1-和-http2-0"}},[_._v("#")]),_._v(" HTTP1.1 和 HTTP2.0")]),_._v(" "),s("ul",[s("li",[s("p",[s("strong",[_._v("多路复用")])]),_._v(" "),s("p",[_._v("http/2 最大特点是使用二进制帧数据进行传输，几个概念如下：")]),_._v(" "),s("p",[s("strong",[_._v("帧：")]),_._v(" http/2 数据通信的最小单位。每个帧都包含帧首部，其中会标识当前帧所属的流。")]),_._v(" "),s("p",[s("strong",[_._v("消息：")]),_._v(" 指 http/2 中逻辑上的 http 消息。例如请求和响应等，消息由一个或多个帧组成。 、")]),_._v(" "),s("p",[s("strong",[_._v("流：")]),_._v(" 存在于连接中的虚拟通道。流可以承接双向消息，每个流都有一个唯一的整数 id。")]),_._v(" "),s("p",[s("strong",[_._v("连接：")]),_._v(" 与 http/1 相同，都是指对应的 TCP 连接。")]),_._v(" "),s("p",[_._v("http/1 的请求和响应报文，都是由起始行、首部和实体正文（可选）组成，各部分之间以文本换行符分隔。而 http/2 将请求和响应数据分隔成为更小的帧，并对他们采用二进制编码。")]),_._v(" "),s("p",[_._v("http/2 中，同域名下的所有请求都在一个连接上完成，这个连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，消息由一个或多个帧组成。多个帧之间可以乱序发送，然后根据帧首部的流标识可以重新组装。")])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("头部数据压缩")])]),_._v(" "),s("p",[_._v("http 请求都是由状态行、请求/响应头部、消息主体三部分组成，一般而言，消息主体都会经过 gzip 压缩，或者本身传输的就是压缩后的二进制文件（例如图片、音频），但是状态行和头部却没有经过任何压缩，直接以文本传输。对于一个请求而言，其 headers 所占的字节数也不少，尤其 cookie，有些时候 headers 甚至超过了主体的大小。")]),_._v(" "),s("p",[_._v("头部压缩使用了 HPACK 算法。会在支持 http/2 的浏览器和服务端之间：")]),_._v(" "),s("ol",[s("li",[_._v("维护一份相同的静态字典，包含常见的头部名称以及特别常见的头部名称和值的组合。\n这样对完全匹配的头部键值对，例如：method：GET，就可以使用一个字符表示。对于头部名称可以匹配的，例如 cookie： xxx，可以将名称使用一个字符表示。")]),_._v(" "),s("li",[_._v("维护一份相同的动态字典，可以动态的添加内容。")]),_._v(" "),s("li",[_._v("支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）")])])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("服务器推送")])]),_._v(" "),s("p",[_._v("支持服务端推送，意味着服务端可以在发送页面 HTML 时主动推送其它资源，而不用等到浏览器解析到相应位置再发起请求。")])])]),_._v(" "),s("h2",{attrs:{id:"拥塞控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#拥塞控制"}},[_._v("#")]),_._v(" 拥塞控制")]),_._v(" "),s("p",[s("strong",[_._v("当出现丢包事件时，让发送方降低其发送速率")]),_._v("，步骤分别有慢启动->拥塞避免>快速恢复。")]),_._v(" "),s("h3",{attrs:{id:"慢启动"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#慢启动"}},[_._v("#")]),_._v(" 慢启动")]),_._v(" "),s("p",[_._v("TCP 发送方初始阶段不是线性地增加其发送率，而是以"),s("strong",[_._v("指数的速度增加")]),_._v("，即"),s("strong",[_._v("每过一个 RTT（数据从网络一端传到另一端所需的时间）将 cwnd（拥塞窗口）值翻倍")]),_._v("。")]),_._v(" "),s("p",[s("strong",[_._v("结束时机：")])]),_._v(" "),s("ol",[s("li",[s("p",[_._v("发生一个由超时指示的丢包事件（即拥塞），将 ssthresh（阈值）状态变量设为 cwnd 值的一半，cwnd 将设为 1 个 MSS（最大传输大小），并重新开始慢启动。")])]),_._v(" "),s("li",[s("p",[_._v("当 cwnd 的值到达或超过 ssthresh 时，结束慢启动，TCP 转移到拥塞避免模式。")])]),_._v(" "),s("li",[s("p",[_._v("若检测到 3 个冗余 ACK，TCP 执行快速重传，并进入快速恢复状态。")])])]),_._v(" "),s("p",[s("strong",[_._v("快速重传：")])]),_._v(" "),s("p",[_._v("快重传算法要求首先接收方收到一个失序的报文段后就立刻发出重复确认，而不要等待自己发送数据时才进行捎带确认。")]),_._v(" "),s("h3",{attrs:{id:"拥塞避免"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#拥塞避免"}},[_._v("#")]),_._v(" 拥塞避免")]),_._v(" "),s("p",[_._v("当 cwnd<ssthresh 的时候，tcp 处于慢启动状态，否则，进入拥塞避免阶段。")]),_._v(" "),s("p",[_._v("拥塞避免的主要思想是加法增大，也就是 "),s("strong",[s("em",[_._v("cwnd 的值")]),s("strong",[_._v("不再指数级往上升，开始")]),_._v("加法增加")]),_._v("。此时"),s("strong",[_._v("当窗口中所有的报文段都被确认时，cwnd 的大小加 1MSS")]),_._v("，即"),s("strong",[_._v("TCP 发送方每收到一个新的确认 ACK，就将 cwnd 增加一个 MSS/cwnd 字节")]),_._v("，cwnd 的值就随着 RTT 开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。")]),_._v(" "),s("p",[s("strong",[_._v("结束时机：")])]),_._v(" "),s("ol",[s("li",[s("p",[_._v("出现"),s("strong",[_._v("超时")]),_._v("，ssthresh 被设置为 cwnd 的一半，cwnd 的值被置为 1 个 MSS，进入慢启动。")])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("收到 3 个冗余 ACK")]),_._v("，ssthresh 被设置为 cwnd 的一半，cwnd 为原来的一半加上 3 个 MSS，进入快速恢复状态。")])])]),_._v(" "),s("h3",{attrs:{id:"快速恢复"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#快速恢复"}},[_._v("#")]),_._v(" 快速恢复")]),_._v(" "),s("ol",[s("li",[s("p",[_._v("当收到 3 个重复 ACK 时，把 ssthresh 设置为 cwnd 的一半，把 cwnd 设置为 ssthresh 的值加 3，然后重传丢失的报文段，即"),s("strong",[_._v("ssthresh=cwnd/2，cwnd=ssthresh+3")]),_._v("；")])]),_._v(" "),s("li",[s("p",[_._v("收到重复的 ACK 时，cwnd 增加 1；")])]),_._v(" "),s("li",[s("p",[_._v("当收到新的数据包的 ACK 时，把"),s("a",{attrs:{href:"https://baike.baidu.com/item/cwnd/5905400",target:"_blank",rel:"noopener noreferrer"}},[_._v("cwnd"),s("OutboundLink")],1),_._v("设置为第一步中的 ssthresh 的值，再次进入拥塞避免状态；")])]),_._v(" "),s("li",[s("p",[_._v("出现"),s("strong",[_._v("超时")]),_._v("，ssthresh 被设置为 cwnd 的一半，cwnd 设为 1 个 MSS，进入慢启动状态。")])])]),_._v(" "),s("p",[_._v("最终呈现锯齿形状：")]),_._v(" "),s("p",[s("img",{attrs:{src:t(388),alt:"image-20200211202558767"}})]),_._v(" "),s("h2",{attrs:{id:"http-状态码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-状态码"}},[_._v("#")]),_._v(" HTTP 状态码")]),_._v(" "),s("p",[_._v("1**：信息，服务器收到请求，需要请求者继续执行操作。")]),_._v(" "),s("p",[_._v("2**：成功，操作被成功接收并处理。")]),_._v(" "),s("p",[_._v("3**：重定向，需要进一步的操作以完成请求。")]),_._v(" "),s("p",[_._v("4**：客户端错误，请求包含语法错误或无法完成请求。")]),_._v(" "),s("p",[_._v("5**：服务器错误，服务器在处理请求的过程中发生了错误。")]),_._v(" "),s("h3",{attrs:{id:"常见状态码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见状态码"}},[_._v("#")]),_._v(" 常见状态码")]),_._v(" "),s("table",[s("thead",[s("tr",[s("th",[_._v("状态码")]),_._v(" "),s("th",[_._v("含义")])])]),_._v(" "),s("tbody",[s("tr",[s("td",[_._v("100")]),_._v(" "),s("td",[_._v("客户端应重新发送初始请求，并在请求中附上第一次请求时未提供的（可能很大或者包含敏感信息的）表示。")])]),_._v(" "),s("tr",[s("td",[_._v("200")]),_._v(" "),s("td",[_._v("表示从客户端发来的请求在服务器端被正确处理。")])]),_._v(" "),s("tr",[s("td",[_._v("201")]),_._v(" "),s("td",[_._v("当服务器依照客户端的请求创建了一个新资源时，发发送此响应代码。")])]),_._v(" "),s("tr",[s("td",[_._v("204")]),_._v(" "),s("td",[_._v("无内容，服务器成功处理了请求，但没有返回任何内容。")])]),_._v(" "),s("tr",[s("td",[_._v("301")]),_._v(" "),s("td",[_._v("永久性重定向，表示资源已被分配了新的 URL。")])]),_._v(" "),s("tr",[s("td",[_._v("302")]),_._v(" "),s("td",[_._v("临时性重定向，表示资源临时被分配了新的 URL。")])]),_._v(" "),s("tr",[s("td",[_._v("303")]),_._v(" "),s("td",[_._v("查看其它位置，表示资源存在着另一个 URL，应使用 GET 方法定向获取资源。")])]),_._v(" "),s("tr",[s("td",[_._v("304")]),_._v(" "),s("td",[_._v("未修改，自从上次请求后，请求的网页未修改过。")])]),_._v(" "),s("tr",[s("td",[_._v("307")]),_._v(" "),s("td",[_._v("临时重定向，和 302 含义相同。")])]),_._v(" "),s("tr",[s("td",[_._v("400")]),_._v(" "),s("td",[_._v("服务器不理解请求的语法。")])]),_._v(" "),s("tr",[s("td",[_._v("401")]),_._v(" "),s("td",[_._v("请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。")])]),_._v(" "),s("tr",[s("td",[_._v("403")]),_._v(" "),s("td",[_._v("服务器拒绝请求。")])]),_._v(" "),s("tr",[s("td",[_._v("404")]),_._v(" "),s("td",[_._v("未找到，服务器找不到请求的网页。")])]),_._v(" "),s("tr",[s("td",[_._v("409")]),_._v(" "),s("td",[_._v("服务器在完成请求时发生冲突，服务器必须在响应中包含有关冲突的信息。")])]),_._v(" "),s("tr",[s("td",[_._v("500")]),_._v(" "),s("td",[_._v("服务器遇到错误，无法完成请求。")])]),_._v(" "),s("tr",[s("td",[_._v("502")]),_._v(" "),s("td",[_._v("服务器作为网关或代理，从上游服务器收到无效响应。")])]),_._v(" "),s("tr",[s("td",[_._v("504")]),_._v(" "),s("td",[_._v("服务器作为网关或代理，但是没有及时从上游服务器收到请求。")])])])]),_._v(" "),s("h2",{attrs:{id:"select、poll、epoll-之间的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#select、poll、epoll-之间的区别"}},[_._v("#")]),_._v(" Select、Poll、Epoll 之间的区别")]),_._v(" "),s("ol",[s("li",[s("p",[_._v("select（O(n)时间复杂度）")]),_._v(" "),s("p",[_._v("基于顺序扫描，select 本质上是通过设置或者检查存放 fd 标志位的数据结构来进行下一步处理，需要无差别轮询所有的数据流，同时，只能监视 fd 的个数为 32 位 1024 个，64 位 2048 个。")])]),_._v(" "),s("li",[s("p",[_._v("poll（O(n)时间复杂度）")]),_._v(" "),s("p",[_._v("本质和 select 没有区别，将用户传入的数组拷贝到内核空间，然后查询每个"),s("strong",[_._v("fd")]),_._v("对应的设备状态，但是没有最大连接数的限制。")])]),_._v(" "),s("li",[s("p",[_._v("epoll（O(1)时间复杂度）")]),_._v(" "),s("p",[_._v("基于事件驱动，流如果发生 I/O 事件会触发异步回调，可以将时间复杂度降为 O(1)，同时没有并发数量的限制。")])])]),_._v(" "),s("table",[s("thead",[s("tr",[s("th"),_._v(" "),s("th",[_._v("select")]),_._v(" "),s("th",[_._v("poll")]),_._v(" "),s("th",[_._v("epoll")])])]),_._v(" "),s("tbody",[s("tr",[s("td",[_._v("操作方式")]),_._v(" "),s("td",[_._v("遍历")]),_._v(" "),s("td",[_._v("遍历")]),_._v(" "),s("td",[_._v("回调")])]),_._v(" "),s("tr",[s("td",[_._v("底层实现")]),_._v(" "),s("td",[_._v("数组")]),_._v(" "),s("td",[_._v("链表")]),_._v(" "),s("td",[_._v("哈希表")])]),_._v(" "),s("tr",[s("td",[_._v("IO 效率")]),_._v(" "),s("td",[_._v("每次调用都进行线性遍历，时间复杂度为 O(n)")]),_._v(" "),s("td",[_._v("每次调用都进行线性遍历，时间复杂度为 O(n)")]),_._v(" "),s("td",[_._v("事件通知方式，每当 fd 就绪，系统注册的回调函数就会被调用，将就绪 fd 放到 readyList 里面，时间复杂度 O(1)")])]),_._v(" "),s("tr",[s("td",[_._v("最大连接数")]),_._v(" "),s("td",[_._v("1024（x86）或 2048（x64）")]),_._v(" "),s("td",[_._v("无上限")]),_._v(" "),s("td",[_._v("无上限")])]),_._v(" "),s("tr",[s("td",[_._v("fd 拷贝")]),_._v(" "),s("td",[_._v("每次调用 select，都需要把 fd 集合从用户态拷贝到内核态")]),_._v(" "),s("td",[_._v("每次调用 poll，都需要把 fd 集合从用户态拷贝到内核态")]),_._v(" "),s("td",[_._v("调用 epoll_ctl 时拷贝进内核并保存，之后每次 epoll_wait 不拷贝")])])])]),_._v(" "),s("h2",{attrs:{id:"tcp-协议计时器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-协议计时器"}},[_._v("#")]),_._v(" TCP 协议计时器")]),_._v(" "),s("ul",[s("li",[s("p",[_._v("超时重传计时器")]),_._v(" "),s("p",[_._v("目的：避免无限等待确认报文。")]),_._v(" "),s("p",[_._v("创建时间：在发送 TCP 报文段时，会为该报文段设置一个超时重传计时器。")]),_._v(" "),s("p",[_._v("可能发生的情况：在超时时间到达之前，收到了该报文段的确认则撤销计时器，否则重传该报文段，并将超时重传计时器复位。")]),_._v(" "),s("p",[_._v("重传时间：2*RTT(RTT 为往返时间）。")])]),_._v(" "),s("li",[s("p",[_._v("坚持计时器")]),_._v(" "),s("p",[_._v("目的：解决零大小窗口导致的死锁问题。")]),_._v(" "),s("p",[_._v("死锁产生原因：当接收端窗口大小为 0 时，发送端停止发送，此后如果接收端有空余空间来接收数据，则发送一个新窗口大小的报文，如果该报文丢失了则导致双方都处于等待状态，产生死锁。")]),_._v(" "),s("p",[_._v("工作原理：当发送端接收到接收端发送的零大小窗口的报文时，就启动坚持计时器，当计时器到达计时时间，发送端就主动发送一个报文段告诉接收端你发送的新窗口大小的报文丢失了，需要重新发送。")]),_._v(" "),s("p",[_._v("坚持时间 开始先设置为超时重传时间，如果超时了还是没有收到接收端发送的新窗口大小报文，则将计时器的值加倍并且复位，直到大于门限值 60s,在此之后每隔 60s 向接收端发送一个询问报文。")])]),_._v(" "),s("li",[s("p",[_._v("保活计时器")]),_._v(" "),s("p",[_._v("目的：避免空闲连接长时间的占用服务器资源。")]),_._v(" "),s("p",[_._v("工作原理：当服务器收到数据时都将保活计时器重新设置（一般 2h），过了 2h 后，服务器如果没有收到数据，每隔 75s 发送一个探测报文给客户端，当连续发送 10 次后，仍然没有收到客户端的回复，则服务器断开连接。")])]),_._v(" "),s("li",[s("p",[_._v("时间等待计时器（为服务器 Time_Wait 状态设置）")]),_._v(" "),s("p",[_._v("服务器主动断开连接时，服务器会保持一个 Time_wait 状态，而时间等待计时器就是 Time_wait 状态的持续时间。")])])]),_._v(" "),s("h2",{attrs:{id:"rto-与-rtt"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rto-与-rtt"}},[_._v("#")]),_._v(" RTO 与 RTT")]),_._v(" "),s("p",[_._v("RTO (Retransmission Time Out)：重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。")]),_._v(" "),s("p",[_._v("RTT (Round Trip Time)：一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值。")]),_._v(" "),s("p",[_._v("RTT 和 RTO 的关系是：由于网络波动的不确定性，每个 RTT 都是动态变化的，所以 RTO 也应随着 RTT 动态变化。")]),_._v(" "),s("h2",{attrs:{id:"http-和-https-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-和-https-的区别"}},[_._v("#")]),_._v(" HTTP 和 HTTPS 的区别")]),_._v(" "),s("table",[s("thead",[s("tr",[s("th"),_._v(" "),s("th",[_._v("HTTP")]),_._v(" "),s("th",[_._v("HTTPS")])])]),_._v(" "),s("tbody",[s("tr",[s("td",[_._v("是否需要 CA")]),_._v(" "),s("td",[_._v("不需要")]),_._v(" "),s("td",[_._v("需要，会产生一定的费用")])]),_._v(" "),s("tr",[s("td",[_._v("是否加密")]),_._v(" "),s("td",[_._v("明文传输")]),_._v(" "),s("td",[_._v("SSL 加密")])]),_._v(" "),s("tr",[s("td",[_._v("端口")]),_._v(" "),s("td",[_._v("80")]),_._v(" "),s("td",[_._v("443")])]),_._v(" "),s("tr",[s("td",[_._v("是否有状态")]),_._v(" "),s("td",[_._v("无状态")]),_._v(" "),s("td",[_._v("有状态")])])])]),_._v(" "),s("p",[_._v("SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层："),s("strong",[_._v("SSL 记录协议")]),_._v("（SSL Record Protocol），它建立在可靠的传输协议（如 TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。"),s("strong",[_._v("SSL 握手协议")]),_._v("（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。")]),_._v(" "),s("h2",{attrs:{id:"https-建立连接的过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https-建立连接的过程"}},[_._v("#")]),_._v(" HTTPS 建立连接的过程")]),_._v(" "),s("p",[s("img",{attrs:{src:t(389),alt:"image-20200211212636712"}})]),_._v(" "),s("ul",[s("li",[s("p",[_._v("客户端发出请求")]),_._v(" "),s("p",[_._v("首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 ClientHello 请求。")])]),_._v(" "),s("li",[s("p",[_._v("服务器回应")]),_._v(" "),s("p",[_._v("服务器收到客户端请求后，向客户端发出回应，这叫做 SeverHello。")])]),_._v(" "),s("li",[s("p",[_._v("客户端回应")]),_._v(" "),s("p",[_._v("客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。")])]),_._v(" "),s("li",[s("p",[_._v("服务器的最后回应")]),_._v(" "),s("p",[_._v('服务器收到客户端的第三个随机数 pre-master key 之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息。')]),_._v(" "),s("ul",[s("li",[_._v("编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。")]),_._v(" "),s("li",[_._v("服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供客户端校验。")])])])]),_._v(" "),s("p",[_._v('至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用"会话密钥"加密内容。')]),_._v(" "),s("h2",{attrs:{id:"https-中间人攻击-为什么需要-ca-认证机构颁发证书"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https-中间人攻击-为什么需要-ca-认证机构颁发证书"}},[_._v("#")]),_._v(" HTTPS 中间人攻击/为什么需要 CA 认证机构颁发证书？")]),_._v(" "),s("p",[_._v("中间人攻击的过程如下：")]),_._v(" "),s("ol",[s("li",[_._v("客户端请求被劫持，将所有的请求发送到中间人的服务器；")]),_._v(" "),s("li",[_._v("中间人服务器返回自己的证书；")]),_._v(" "),s("li",[_._v("客户端创建随机数，使用中间人证书中的公钥进行加密发送给中间人服务器，中间人使用私钥对随机数解密并构造对称加密，对之后传输的内容进行加密传输；")]),_._v(" "),s("li",[_._v("中间人通过客户端的随机数对客户端的数据进行解密；")]),_._v(" "),s("li",[_._v("中间人与服务端建立合法的 https 连接（https 握手过程），与服务端之间使用对称加密进行数据传输，拿到服务端的响应数据，并通过与服务端建立的对称加密的秘钥进行解密；")]),_._v(" "),s("li",[_._v("中间人再通过与客户端建立的对称加密对响应数据进行加密后传输给客户端；")]),_._v(" "),s("li",[_._v("客户端通过与中间人建立的对称加密的秘钥对数据进行解密。")])]),_._v(" "),s("p",[_._v("简单来说，中间人攻击中，中间人首先伪装成服务端和客户端通信，然后又伪装成客户端和服务端进行通信（如图）。 整个过程中，由于缺少了证书的验证过程，虽然使用了 https，但是传输的数据已经被监听，客户端却无法得知。")]),_._v(" "),s("p",[s("img",{attrs:{src:t(390),alt:"image-20200229215736657"}})]),_._v(" "),s("h2",{attrs:{id:"如何验证证书的合法性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何验证证书的合法性"}},[_._v("#")]),_._v(" 如何验证证书的合法性？")]),_._v(" "),s("p",[_._v("CA 证书中会包含颁发机构信息、公钥、公司信息、域名、有效期等信息，浏览器验证证书：")]),_._v(" "),s("ol",[s("li",[_._v("首先就是要验证域名、有效期等信息是否正确；")]),_._v(" "),s("li",[_._v("然后判断证书来源的合法性。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证；")]),_._v(" "),s("li",[_._v("判断证书是否被篡改。需要与 CA 服务器进行校验；")]),_._v(" "),s("li",[_._v("判断证书是否已吊销。")])]),_._v(" "),s("p",[_._v("以上任意一步都满足的情况下浏览器才认为证书是合法的。")]),_._v(" "),s("h2",{attrs:{id:"在浏览器的-url-中输入一个-https-请求会发生什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在浏览器的-url-中输入一个-https-请求会发生什么"}},[_._v("#")]),_._v(" 在浏览器的 URL 中输入一个 HTTPS 请求会发生什么？")]),_._v(" "),s("ul",[s("li",[_._v("首先进行域名解析，域名解析具体过程讲一下：\n"),s("ol",[s("li",[s("strong",[_._v("浏览器")]),_._v("搜索自己的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表；")]),_._v(" "),s("li",[_._v("若没有，则搜索"),s("strong",[_._v("操作系统")]),_._v("的 DNS 缓存；")]),_._v(" "),s("li",[_._v("若没有，则操作系统将域名发送至本地域名服务器（递归查询方式），"),s("strong",[_._v("本地域名服务器")]),_._v("查询自己的"),s("strong",[_._v("DNS 缓存")]),_._v("，查找成功则返回结果，否则，通过以下方式迭代查找：")]),_._v(" "),s("li",[_._v("本地域名服务器向"),s("strong",[_._v("根域名服务器")]),_._v("发起请求，根域名服务器返回 com 域的顶级域名服务器的地址；")]),_._v(" "),s("li",[_._v("本地域名服务器向 com 域的顶级域名服务器发起请求，返回权限域名服务器地址；")]),_._v(" "),s("li",[_._v("本地域名服务器向权限域名服务器发起请求，得到 IP 地址。")]),_._v(" "),s("li",[_._v("本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来；\n操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；\n至此，浏览器已经得到了域名对应的 IP 地址。")])])]),_._v(" "),s("li",[_._v("浏览器发起 HTTP 请求；")]),_._v(" "),s("li",[_._v("接下来到了传输层，选择传输协议，TCP 或者 UDP，TCP 是可靠的传输控制协议，对 HTTP 请求进行封装，加入了端口号等信息；")]),_._v(" "),s("li",[_._v("然后到了网络层，通过 IP 协议将 IP 地址封装为 IP 数据报；然后此时会用到 ARP 协议，主机发送信息时将包含目标 IP 地址的 ARP 请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，找到目的 MAC 地址；")]),_._v(" "),s("li",[_._v("接下来到了数据链路层，把网络层交下来的 IP 数据报添加首部和尾部，封装为 MAC 帧，现在根据目的 mac 开始建立 TCP 连接，三次握手（详细讲）。")]),_._v(" "),s("li",[_._v("建立了 TCP 连接后，如果使用 HTTPS，则需要进行 SSL 握手，沟通加密参数（如，SSL 版本）以及交换秘钥，握手完成后，报文会在发送给 TCP 之前在 SSL 层进行加密。")]),_._v(" "),s("li",[_._v("建立了 TCP 连接便可以发送 HTTP 请求了，HTTP 请求通过 TCP 协议发到 Server 端。")]),_._v(" "),s("li",[_._v("接收端在收到物理层上交的比特流后，根据首尾的标记，识别帧的开始和结束，将中间的数据部分上交给网络层，然后层层向上传递到应用层；")]),_._v(" "),s("li",[_._v("服务器响应请求并请求客户端要的资源，传回给客户端；")]),_._v(" "),s("li",[_._v("断开 TCP 连接，浏览器对页面进行渲染呈现给客户端。")])]),_._v(" "),s("h2",{attrs:{id:"tcp-与-http-的关系-基于-tcp-实现-http"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-与-http-的关系-基于-tcp-实现-http"}},[_._v("#")]),_._v(" TCP 与 HTTP 的关系，基于 TCP 实现 HTTP")]),_._v(" "),s("p",[_._v("TCP 是传输层的协议，HTTP 是应用层的协议，HTTP 协议基于 TCP 通信。")]),_._v(" "),s("p",[_._v("实现思路如下：")]),_._v(" "),s("ol",[s("li",[s("p",[_._v("http 协议是基于 TCP 通信的协议，因此，实现 web 服务器的第一步至少要能实现两个主机不同进程之间的 TCP 通信。")])]),_._v(" "),s("li",[s("p",[_._v("接下来的部分就是比较主要的处理逻辑了，当服务器收到请求后，首先应该分析请求方法。（因为 web 服务器是要支持 cgi 的，但请求方法不同处理 cgi 也不同，这里我们只处理 GET 和 POST 方法）")])]),_._v(" "),s("li",[s("p",[_._v("当方法确定后，应该拿到请求的 URL，这一步是为了我们后边能处理 GET 和 POST 方法的 cgi。（GET 和 POST 的参数位置不同，GET 的参数在 URL 中，POST 的参数在请求正文中）")])]),_._v(" "),s("li",[s("p",[_._v("判断资源是否存在，如果存在，判断这个资源是一个目录、普通文件还是一个可执行程序。之前几步我们已经提取到 URL 以及参数。GET 方法：如果没有参数，就直接将请求的资源返回（即进入非 cgi 模式运行）；否则，进入 cgi 模式内部运行；只要是 POST 方法就需要支持 cgi：直接进入 cgi 函数内部运行。非 cgi 模式： 进入非 cgi 模式时一定是 GET 方法且没有参数，此时进入 echo_www()函数内部即可，该函数会将所请求的资源以 html 的格式返回给浏览器。")])])]),_._v(" "),s("h3",{attrs:{id:"cgi-模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cgi-模式"}},[_._v("#")]),_._v(" cgi 模式")]),_._v(" "),s("p",[_._v("首先服务器要从浏览器上读取参数，然后需要 fork 出一个子进程进行 cgi 部分的处理，父进程通过环境变量的方式将参数转交给子进程，子进程运行完成后，将结果交给父进程，父进程再将数据输出给浏览器。在这个过程中可以将父进程看作一个所谓的中间量，只进行了参数的转交，因此可以将子进程的输入输出文件描述符进行重定向，即子进程直接与浏览器“联系”。")]),_._v(" "),s("p",[s("img",{attrs:{src:t(391),alt:"image-20200308153027902"}})]),_._v(" "),s("p",[s("img",{attrs:{src:t(392),alt:"image-20200308153052652"}})]),_._v(" "),s("h2",{attrs:{id:"路由器和交换机的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#路由器和交换机的区别"}},[_._v("#")]),_._v(" 路由器和交换机的区别")]),_._v(" "),s("p",[_._v("交换机比"),s("a",{attrs:{href:"https://www.baidu.com/s?wd=%E8%B7%AF%E7%94%B1%E5%99%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao",target:"_blank",rel:"noopener noreferrer"}},[_._v("路由器"),s("OutboundLink")],1),_._v("更简单，"),s("a",{attrs:{href:"https://www.baidu.com/s?wd=%E8%B7%AF%E7%94%B1%E5%99%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao",target:"_blank",rel:"noopener noreferrer"}},[_._v("路由器"),s("OutboundLink")],1),_._v("比交换器能获取更多信息。")]),_._v(" "),s("ul",[s("li",[s("p",[_._v("工作层次不同")]),_._v(" "),s("p",[_._v("交换机工作在数据链路层；")]),_._v(" "),s("p",[_._v("路由器工作在网络层。")])]),_._v(" "),s("li",[s("p",[_._v("数据转发所依据的对象不同")]),_._v(" "),s("p",[_._v("交换机的数据转发依据是利用"),s("strong",[_._v("物理地址")]),_._v("或者说"),s("strong",[_._v("MAC 地址")]),_._v("来确定转发数据的目的地址；")]),_._v(" "),s("p",[_._v("路由器是依据"),s("strong",[_._v("ip 地址")]),_._v("进行工作的。")])]),_._v(" "),s("li",[s("p",[_._v("分割域不同")]),_._v(" "),s("p",[_._v("传统的交换机只能分割冲突域，不能分割广播域；")]),_._v(" "),s("p",[_._v("路由器可以分割广播域。")])])]),_._v(" "),s("h2",{attrs:{id:"重定向和转发的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重定向和转发的区别"}},[_._v("#")]),_._v(" 重定向和转发的区别")]),_._v(" "),s("table",[s("thead",[s("tr",[s("th"),_._v(" "),s("th",[_._v("forward")]),_._v(" "),s("th",[_._v("redirect")])])]),_._v(" "),s("tbody",[s("tr",[s("td",[_._v("地址栏")]),_._v(" "),s("td",[_._v("地址不变。服务器直接访问目标地址的 URL,把那个 URL 的响应内容读取过来,然后把这些内容再发给浏览器")]),_._v(" "),s("td",[_._v("地址发生改变。服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址")])]),_._v(" "),s("tr",[s("td",[_._v("数据共享")]),_._v(" "),s("td",[_._v("转发页面和转发到的页面可以共享 request 里面的数据")]),_._v(" "),s("td",[_._v("不可以共享")])]),_._v(" "),s("tr",[s("td",[_._v("运用场景")]),_._v(" "),s("td",[_._v("一般用于用户登陆的时候,根据角色转发到相应的模块")]),_._v(" "),s("td",[_._v("一般用于用户注销登陆时返回主页面和跳转到其它的网站等")])]),_._v(" "),s("tr",[s("td",[_._v("效率")]),_._v(" "),s("td",[_._v("高")]),_._v(" "),s("td",[_._v("低")])])])]),_._v(" "),s("h2",{attrs:{id:"cookie-和-session-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cookie-和-session-的区别"}},[_._v("#")]),_._v(" cookie 和 session 的区别")]),_._v(" "),s("table",[s("thead",[s("tr",[s("th"),_._v(" "),s("th",[_._v("cookie")]),_._v(" "),s("th",[_._v("session")])])]),_._v(" "),s("tbody",[s("tr",[s("td",[_._v("存放位置")]),_._v(" "),s("td",[_._v("浏览器")]),_._v(" "),s("td",[_._v("服务器")])]),_._v(" "),s("tr",[s("td",[_._v("安全性")]),_._v(" "),s("td",[_._v("不安全")]),_._v(" "),s("td",[_._v("安全")])]),_._v(" "),s("tr",[s("td",[_._v("性能")]),_._v(" "),s("td",[_._v("对服务器压力小")]),_._v(" "),s("td",[_._v("当访问增多时，服务器压力大")])]),_._v(" "),s("tr",[s("td",[_._v("数据大小")]),_._v(" "),s("td",[_._v("有大小限制，不能超过 4K，很多浏览器最多保存 20 个 cookie")]),_._v(" "),s("td",[_._v("没有大小限制")])])])]),_._v(" "),s("h2",{attrs:{id:"bs-与-cs-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bs-与-cs-的区别"}},[_._v("#")]),_._v(" BS 与 CS 的区别")]),_._v(" "),s("table",[s("thead",[s("tr",[s("th"),_._v(" "),s("th",[_._v("BS")]),_._v(" "),s("th",[_._v("CS")])])]),_._v(" "),s("tbody",[s("tr",[s("td",[_._v("客户端")]),_._v(" "),s("td",[_._v("只需要浏览器")]),_._v(" "),s("td",[_._v("需要安装专门的软件")])]),_._v(" "),s("tr",[s("td",[_._v("硬件")]),_._v(" "),s("td",[_._v("建立在广域网")]),_._v(" "),s("td",[_._v("建立在专用网络")])]),_._v(" "),s("tr",[s("td",[_._v("安全要求")]),_._v(" "),s("td",[_._v("相对弱")]),_._v(" "),s("td",[_._v("对安全信息控制能力强")])]),_._v(" "),s("tr",[s("td",[_._v("程序架构")]),_._v(" "),s("td",[_._v("更注重安全和访问速度")]),_._v(" "),s("td",[_._v("更注重流程")])]),_._v(" "),s("tr",[s("td",[_._v("重用性")]),_._v(" "),s("td",[_._v("好")]),_._v(" "),s("td",[_._v("弱")])]),_._v(" "),s("tr",[s("td",[_._v("维护性")]),_._v(" "),s("td",[_._v("轻松")]),_._v(" "),s("td",[_._v("较困难")])]),_._v(" "),s("tr",[s("td",[_._v("开发难度")]),_._v(" "),s("td",[_._v("低")]),_._v(" "),s("td",[_._v("高")])])])])])}),[],!1,null,null,null);v.default=a.exports}}]);