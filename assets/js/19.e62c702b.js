(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{419:function(t,o,r){"use strict";r.r(o);var s=r(42),a=Object(s.a)({},(function(){var t=this,o=t.$createElement,r=t._self._c||o;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"storm"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#storm"}},[t._v("#")]),t._v(" Storm")]),t._v(" "),r("p",[t._v("Storm 是 Twitter 开源的分布式实时大数据处理框架，最早开源于 github，从 0.9.1 版本之后，归于 Apache 社区，被业界称为实时版 Hadoop。随着越来越多的场景对 Hadoop 的 MapReduce 高延迟无法容忍，比如网站统计、推荐系统、预警系统、金融系统(高频交易、股票)等等，大数据实时处理解决方案（流计算）的应用日趋广泛，目前已是分布式技术领域最新爆发点，而 Storm 更是流计算技术中的佼佼者和主流。")]),t._v(" "),r("h2",{attrs:{id:"核心组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#核心组件"}},[t._v("#")]),t._v(" 核心组件")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("Nimbus")]),t._v("：即 Storm 的 Master，负责资源分配和任务调度。一个 Storm 集群只有一个 Nimbus。")]),t._v(" "),r("li",[r("strong",[t._v("Supervisor")]),t._v("：即 Storm 的 Slave，负责接收 Nimbus 分配的任务，管理所有 Worker，一个 Supervisor 节点中包含多个 Worker 进程。")]),t._v(" "),r("li",[r("strong",[t._v("Worker")]),t._v("：工作进程，每个工作进程中都有多个 Task。")]),t._v(" "),r("li",[r("strong",[t._v("Task")]),t._v("：任务，在 Storm 集群中每个 Spout 和 Bolt 都由若干个任务（tasks）来执行。每个任务都与一个执行线程相对应。")]),t._v(" "),r("li",[r("strong",[t._v("Topology")]),t._v("：计算拓扑，Storm 的拓扑是对实时计算应用逻辑的封装，它的作用与 MapReduce 的任务（Job）很相似，区别在于 MapReduce 的一个 Job 在得到结果之后总会结束，而拓扑会一直在集群中运行，直到你手动去终止它。拓扑还可以理解成由一系列通过数据流（Stream Grouping）相互关联的 Spout 和 Bolt 组成的的拓扑结构。")]),t._v(" "),r("li",[r("strong",[t._v("Stream")]),t._v("：数据流（Streams）是 Storm 中最核心的抽象概念。一个数据流指的是在分布式环境中并行创建、处理的一组元组（tuple）的无界序列。数据流可以由一种能够表述数据流中元组的域（fields）的模式来定义。")]),t._v(" "),r("li",[r("strong",[t._v("Spout")]),t._v("：数据源（Spout）是拓扑中数据流的来源。一般 Spout 会从一个外部的数据源读取元组然后将他们发送到拓扑中。根据需求的不同，Spout 既可以定义为可靠的数据源，也可以定义为不可靠的数据源。一个可靠的 Spout 能够在它发送的元组处理失败时重新发送该元组，以确保所有的元组都能得到正确的处理；相对应的，不可靠的 Spout 就不会在元组发送之后对元组进行任何其他的处理。一个 Spout 可以发送多个数据流。")]),t._v(" "),r("li",[r("strong",[t._v("Bolt")]),t._v("：拓扑中所有的数据处理均是由 Bolt 完成的。通过数据过滤（filtering）、函数处理（functions）、聚合（aggregations）、联结（joins）、数据库交互等功能，Bolt 几乎能够完成任何一种数据处理需求。一个 Bolt 可以实现简单的数据流转换，而更复杂的数据流变换通常需要使用多个 Bolt 并通过多个步骤完成。")]),t._v(" "),r("li",[r("strong",[t._v("Stream grouping")]),t._v("：为拓扑中的每个 Bolt 的确定输入数据流是定义一个拓扑的重要环节。数据流分组定义了在 Bolt 的不同任务（tasks）中划分数据流的方式。在 Storm 中有八种内置的数据流分组方式。")]),t._v(" "),r("li",[r("strong",[t._v("Reliability")]),t._v("：可靠性。Storm 可以通过拓扑来确保每个发送的元组都能得到正确处理。通过跟踪由 Spout 发出的每个元组构成的元组树可以确定元组是否已经完成处理。每个拓扑都有一个“消息延时”参数，如果 Storm 在延时时间内没有检测到元组是否处理完成，就会将该元组标记为处理失败，并会在稍后重新发送该元组。")])]),t._v(" "),r("h2",{attrs:{id:"提高并行度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#提高并行度"}},[t._v("#")]),t._v(" 提高并行度")]),t._v(" "),r("p",[t._v("并行度就是多线程，主要是调整三个实体\n1.worker 进程\n2.exectors（线程）\n3.Task（线程)\n在 worker 下可以可以采用多线程的方式运行程序。task 是运行在 exector 里面的。")]),t._v(" "),r("h2",{attrs:{id:"storm-的可靠性如何实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#storm-的可靠性如何实现"}},[t._v("#")]),t._v(" Storm 的可靠性如何实现")]),t._v(" "),r("h3",{attrs:{id:"acker-任务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#acker-任务"}},[t._v("#")]),t._v(" acker 任务")]),t._v(" "),r("p",[t._v('一个 Storm 拓扑有一组特殊的"acker"任务，它们负责跟踪由每个 Spout 元组触发的消息的处理状态。当一个"acker"看到一个 Spout 元组产生的有向无环图中的消息被完全处理，就通知当初创建这个 Spout 元组的 Spout 任务，这个元组被成功处理。')]),t._v(" "),r("h3",{attrs:{id:"元组的生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#元组的生命周期"}},[t._v("#")]),t._v(" 元组的生命周期")]),t._v(" "),r("p",[t._v("理解 Storm 的可靠性实现方式的最好方法是查看元组的生命周期和元组构成的有向无环图。")]),t._v(" "),r("p",[t._v("当一个 Spout 任务产出一个新的元组，仅需要简单的发送一个消息给对应的 acker(Spout 元组 message-id 哈希取模)来告知 Spout 的任务标示(task id)，以此来通知 acker 当前这个 Spout 任务负责这个消息。当 acker 看到一个消息树被完全处理完，它就能根据处理的元组中携带的 Spout 元组 message-id 来确定产生这个 Spout 元组的 task id，然后通知这个 Spout 任务消息树处理完成(调用 Spout 任务的"),r("code",[t._v("ack")]),t._v("函数)。")]),t._v(" "),r("h2",{attrs:{id:"storm-实现对单词的计数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#storm-实现对单词的计数"}},[t._v("#")]),t._v(" storm 实现对单词的计数")]),t._v(" "),r("p",[t._v("单词计数 topology 由一个 spout 和三个 bolt 组成。")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("spout")]),t._v(" "),r("p",[t._v("动态的接受数据源信息。")])]),t._v(" "),r("li",[r("p",[t._v("语句分割 bolt")]),t._v(" "),r("p",[t._v("将每个句子分割成单词。")])]),t._v(" "),r("li",[r("p",[t._v("单词统计技术 bolt")]),t._v(" "),r("p",[t._v("把语句分割的 bolt 的输出作为输入，统计每个单词的数量。")])]),t._v(" "),r("li",[r("p",[t._v("上报 bolt")]),t._v(" "),r("p",[t._v("当收到一个 tuple 时，上报 bolt 会更新表中的计数数据，并且将值在终端打印。")])])])])}),[],!1,null,null,null);o.default=a.exports}}]);