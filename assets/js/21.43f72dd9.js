(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{425:function(t,e,v){"use strict";v.r(e);var _=v(42),n=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"netty"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#netty"}},[t._v("#")]),t._v(" Netty")]),t._v(" "),v("h2",{attrs:{id:"netty-是什么-为什么要用-netty"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#netty-是什么-为什么要用-netty"}},[t._v("#")]),t._v(" Netty 是什么，为什么要用 Netty")]),t._v(" "),v("p",[t._v("Netty 是一款基于 NIO 开发的网络通信框架，在易用的同时，没有丧失可维护性和性能等优势。")]),t._v(" "),v("p",[t._v("特点：高并发（NIO）、传输快（零拷贝）、封装好。")]),t._v(" "),v("h2",{attrs:{id:"零拷贝是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#零拷贝是什么"}},[t._v("#")]),t._v(" 零拷贝是什么")]),t._v(" "),v("p",[t._v("零拷贝主要体现在三个方面：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("Netty 的接受和发送 ByteBuffer 采用"),v("strong",[t._v("Direct Buffers")]),t._v("，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。")])]),t._v(" "),v("li",[v("p",[t._v("提供了"),v("strong",[t._v("组合 Buffer 对象")]),t._v("，可以聚合多个 ByteBuffer 对象，避免了传统通过内存拷贝将几个小 buffer 合并成一个大 Buffer。")])]),t._v(" "),v("li",[v("p",[t._v("Netty 的文件传输采用了"),v("strong",[t._v("transferTo")]),t._v("方法，它可以直接将"),v("strong",[t._v("文件缓冲区")]),t._v("的数据发送到"),v("strong",[t._v("目标 Channel")]),t._v("，避免了传统通过循环 write 方式导致的内存拷贝问题。")])])]),t._v(" "),v("h2",{attrs:{id:"netty-有什么组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#netty-有什么组件"}},[t._v("#")]),t._v(" Netty 有什么组件")]),t._v(" "),v("p",[v("strong",[t._v("Bootstrap")]),t._v(": 引导类，提供一个用于应用程序网络层配置的容器。")]),t._v(" "),v("p",[v("strong",[t._v("Channel")]),t._v("：底层网络传输 API 必须提供给 I/O 操作的接口。")]),t._v(" "),v("p",[v("strong",[t._v("ChannelHandler")]),t._v("：channelHandler 支持很多协议，并且提供用于数据处理的容器。")]),t._v(" "),v("p",[v("strong",[t._v("ChannelInboundHandler")]),t._v(":这个类型接收到入站事件（包括接收到的数据）可以处理应用程序逻辑")]),t._v(" "),v("p",[v("strong",[t._v("ChannelPipeline")]),t._v("：提供一个容器给 channelHandler 链并提供一个 API 用于管理沿着链入站和出站事件的流动。每个 Channel 都有自己的 ChannelPipeline，是当 Channel 创建时自动被创建的。")]),t._v(" "),v("p",[v("strong",[t._v("EventLoop")]),t._v("：用于处理 I/O 操作。一个单一的 EventLoop 通常会处理多个 Channel 事件。")]),t._v(" "),v("p",[v("strong",[t._v("EventLoopGroup")]),t._v("：可以含有多于一个的 EventLoop 和提供一个迭代用于检索清单中的下一个。")]),t._v(" "),v("p",[v("strong",[t._v("ChannelFuture")]),t._v("：Netty 所有的 I/O 操作都是异步的。因为一个操作可能无法立即返回，我们需要有一种方法在以后确定这个操作的返回结果。出于这个目的，Netty 提供了接口 ChannelFuture，它的 addLiListener 方法注册了一个 ChannelFutureListener，当操作完成时，可以被通知。")]),t._v(" "),v("p",[t._v("关系：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("Socket 和 Channel 是一对一。")])]),t._v(" "),v("li",[v("p",[t._v("Channel 和 EventLoop 是多对一。")])]),t._v(" "),v("li",[v("p",[t._v("EventLoop 和 EventLoopgroup 是多对一。")])]),t._v(" "),v("li",[v("p",[t._v("EventLoop 和 Thread 是一对一。")])]),t._v(" "),v("li",[v("p",[t._v("ChannelHandler 和 ChannelPipeline 是多对一。")])]),t._v(" "),v("li",[v("p",[t._v("ChannelPipeline 和 Channel 是一对一。")])])]),t._v(" "),v("h2",{attrs:{id:"粘包和半包问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#粘包和半包问题"}},[t._v("#")]),t._v(" 粘包和半包问题")]),t._v(" "),v("p",[t._v("粘包：发送方每次写入数据<套接字缓冲区的大小；接收方读取数据不及时。")]),t._v(" "),v("p",[t._v("半包：发送方每次写入数据>套接字缓冲区的大小；发送的数据大于协议的最大传输单元，必须拆包。")]),t._v(" "),v("p",[t._v("根本原因：TCP 是流式协议，消息无边界。")]),t._v(" "),v("p",[t._v("解决方法：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("改成短连接（不推荐）")])]),t._v(" "),v("li",[v("p",[t._v("封装成帧（固定长度、分隔符、专门的 length 字段）")])])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("方式")]),t._v(" "),v("th",[t._v("解码")]),t._v(" "),v("th",[t._v("编码")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("固定长度")]),t._v(" "),v("td",[t._v("FixedLengthFrameDecoder")]),t._v(" "),v("td",[t._v("/")])]),t._v(" "),v("tr",[v("td",[t._v("分隔符")]),t._v(" "),v("td",[t._v("DelimiterBasedFrameDecoder")]),t._v(" "),v("td",[t._v("/")])]),t._v(" "),v("tr",[v("td",[t._v("专门的 length 字段")]),t._v(" "),v("td",[t._v("LengthFieldBasedFrameDecoder")]),t._v(" "),v("td",[t._v("LengthFieldPrepender")])])])]),t._v(" "),v("h2",{attrs:{id:"netty-的序列化问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#netty-的序列化问题"}},[t._v("#")]),t._v(" Netty 的序列化问题")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("XML（较差）")])]),t._v(" "),v("li",[v("p",[t._v("JSON")])]),t._v(" "),v("li",[v("p",[t._v("Fastjson")])]),t._v(" "),v("li",[v("p",[t._v("Thrift")])]),t._v(" "),v("li",[v("p",[t._v("Avro（优秀）")])]),t._v(" "),v("li",[v("p",[t._v("Protobuf（优秀）")])])]),t._v(" "),v("h2",{attrs:{id:"netty-线程模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#netty-线程模型"}},[t._v("#")]),t._v(" Netty 线程模型")]),t._v(" "),v("p",[t._v("Netty 结合了 Selector 和 Reactor 模式设计了高效的线程模型，主要角色包括 Selector、EventLoopGroup/EventLoop、ChannelPipeline。")]),t._v(" "),v("p",[t._v("首先，Selector 是一个多路复用器，负责将就绪的 IO 事件分离出来，BossEventLoopGroup 会负责接收，通常是一个单线程，根据事件分发到 WorkerEventLoopGroup，随后通过 ChannelPipeline 将请求进行处理，ChannelPipeline 内部是一个 ChannelHandler 链表，负责具体的处理。")]),t._v(" "),v("h2",{attrs:{id:"优雅退出"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优雅退出"}},[t._v("#")]),t._v(" 优雅退出")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("把 NIO 线程的状态位设置成 ST_SHUTTING_DOWN 状态，不再处理新的消息（不允许再对外发送消息）；")])]),t._v(" "),v("li",[v("p",[t._v("退出前的预处理操作：把发送队列中尚未发送或者正在发送的消息发送完、把已经到期或者在退出超时之前到期的定时任务执行完成、把用户注册到 NIO 线程的退出 Hook 任务执行完成；")])]),t._v(" "),v("li",[v("p",[t._v("资源的释放操作：所有 Channel 的释放、多路复用器的注册和关闭、所有队列和定时任务的清空取消，最后是 NIO 线程的退出。")])])]),t._v(" "),v("h2",{attrs:{id:"内存分配"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存分配"}},[t._v("#")]),t._v(" 内存分配")]),t._v(" "),v("p",[t._v("主要分为 Arena、ChunkList、Chunk、Page、Subpage 这 5 个层级。")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("需要分配的内存小于 PageSize 时，分配 tiny 或者 small 内存。")])]),t._v(" "),v("li",[v("p",[t._v("需要分配的内存介于 PageSize 和 ChunkSize 时，则分配 normal 内存。")])]),t._v(" "),v("li",[v("p",[t._v("需要分配的内存大于 ChunkSize 时，则分配 huge 内存（非池化内存）。")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);