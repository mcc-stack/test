(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{375:function(t,s,a){t.exports=a.p+"assets/img/image-20200216223320506.bbb787e1.png"},421:function(t,s,a){"use strict";a.r(s);var e=a(42),v=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"mybatis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mybatis"}},[t._v("#")]),t._v(" MyBatis")]),t._v(" "),e("h2",{attrs:{id:"orm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#orm"}},[t._v("#")]),t._v(" ORM")]),t._v(" "),e("p",[t._v("即 Object-Relational Mapping，它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的 SQL 语句打交道，只要像平时操作对象一样操作它就可以了 。")]),t._v(" "),e("h2",{attrs:{id:"mybatis-的优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mybatis-的优点"}},[t._v("#")]),t._v(" MyBatis 的优点")]),t._v(" "),e("ol",[e("li",[t._v("使用线程池，复用；")]),t._v(" "),e("li",[t._v("方便配置；")]),t._v(" "),e("li",[t._v("对 SQL 有较好的封装。")])]),t._v(" "),e("p",[e("strong",[t._v("与 Hibernate 的横向对比：")])]),t._v(" "),e("table",[e("thead",[e("tr",[e("th"),t._v(" "),e("th",[t._v("MyBatis")]),t._v(" "),e("th",[t._v("Hibernate")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("ORM 标准程度")]),t._v(" "),e("td",[t._v("半标准")]),t._v(" "),e("td",[t._v("完全标准")])]),t._v(" "),e("tr",[e("td",[t._v("难易程度")]),t._v(" "),e("td",[t._v("简单")]),t._v(" "),e("td",[t._v("难")])]),t._v(" "),e("tr",[e("td",[t._v("不同数据库的迁移难易度")]),t._v(" "),e("td",[t._v("难")]),t._v(" "),e("td",[t._v("简单")])]),t._v(" "),e("tr",[e("td",[t._v("重量级")]),t._v(" "),e("td",[t._v("轻量")]),t._v(" "),e("td",[t._v("重量")])])])]),t._v(" "),e("h2",{attrs:{id:"原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),e("p",[e("img",{attrs:{src:a(375),alt:"image-20200216223320506"}})]),t._v(" "),e("ol",[e("li",[e("p",[t._v("读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。")])]),t._v(" "),e("li",[e("p",[t._v("加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。")])]),t._v(" "),e("li",[e("p",[t._v("构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。")])]),t._v(" "),e("li",[e("p",[t._v("创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。")])]),t._v(" "),e("li",[e("p",[t._v("Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。")])]),t._v(" "),e("li",[e("p",[t._v("MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。")])]),t._v(" "),e("li",[e("p",[t._v("输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。")])]),t._v(" "),e("li",[e("p",[t._v("输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。")])])]),t._v(" "),e("h2",{attrs:{id:"和-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#和-的区别"}},[t._v("#")]),t._v(" ${}和#{}的区别")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("#{} 解析为一个 JDBC "),e("strong",[t._v("预编译语句")]),t._v("（prepared statement）的参数标记符，一个 #{ } 被解析为一个"),e("strong",[t._v("参数占位符")]),t._v("；而${}仅仅为一个纯碎的 string 替换，在动态 SQL 解析阶段将会进行变量替换。")])]),t._v(" "),e("li",[e("p",[t._v("#{} 解析之后会将"),e("strong",[t._v("String 类型")]),t._v("的数据自动加上引号，其他数据类型不会；而${} 解析之后是什么就是什么，他不会当做字符串处理。")])]),t._v(" "),e("li",[e("p",[t._v("#{} 很大程度上可以"),e("strong",[t._v("防止 SQL 注入")]),t._v("（SQL 注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译成了恶意的执行操作）；而${} 主要用于 SQL 拼接的时候，有很大的 SQL 注入隐患。")])]),t._v(" "),e("li",[e("p",[t._v("在某些特殊场合下只能用${}，不能用#{}。例如：在使用排序时ORDER BY ${id}，如果使用#{id}，则会被解析成 ORDER BY “id”,这显然是一种错误的写法。")])])]),t._v(" "),e("h2",{attrs:{id:"动态-sql"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态-sql"}},[t._v("#")]),t._v(" 动态 SQL")]),t._v(" "),e("p",[e("strong",[t._v("使用场景：")])]),t._v(" "),e("p",[t._v("对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，需要根据用户指定的条件动态生成 SQL 语句。")]),t._v(" "),e("p",[e("strong",[t._v("主要元素：")])]),t._v(" "),e("ul",[e("li",[t._v("if")]),t._v(" "),e("li",[t._v("choose / when / otherwise")]),t._v(" "),e("li",[t._v("trim：可以用于 where 和 set，可以写前缀与后缀")]),t._v(" "),e("li",[t._v("where")]),t._v(" "),e("li",[t._v("set")]),t._v(" "),e("li",[t._v("foreach")])]),t._v(" "),e("h2",{attrs:{id:"命名空间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#命名空间"}},[t._v("#")]),t._v(" 命名空间")]),t._v(" "),e("p",[t._v("在 MyBatis 中，可以为每个映射文件起一个唯一的命名空间（接口的全限定名），这样定义在这个映射文件中的每个 SQL 语句就成了定义在这个命名空间中的一个 ID。只要我们能够保证每个命名空间中这个 ID 是唯一的，即使在不同映射文件中的语句 ID 相同，也不会再产生冲突了。")]),t._v(" "),e("h2",{attrs:{id:"接口和-xml-的关联"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接口和-xml-的关联"}},[t._v("#")]),t._v(" 接口和 XML 的关联")]),t._v(" "),e("p",[t._v("当调用一个接口的方法时，会先通过接口的全限定名称和当前调用的方法名的组合得到一个方法 id，这个 id 的值就是映射 XML 中 namespace 和具体方法 id 的组合。所以可以在代理方法中使用 "),e("strong",[t._v("sqlSession")]),t._v(" 以命名空间的方式调用方法。通过这种方式可以将接口和 XML 文件中的方法关联起来。")]),t._v(" "),e("h2",{attrs:{id:"缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[t._v("#")]),t._v(" 缓存")]),t._v(" "),e("p",[t._v("MyBatis 中使用缓存来提高其性能。")]),t._v(" "),e("p",[t._v("MyBatis 中的缓存分为两种：一级缓存和二级缓存。使用过 MyBatis 的可能听到过这样一句话“一级缓存是 sqlSession 级别的，二级缓存是 mapper 级别的”。这也说明了，当使用同一个 sqlSession 时，查询到的数据可能是一级缓存；而当使用同一个 mapper 是，查询到的数据可能是二级缓存。")]),t._v(" "),e("p",[t._v("如果配置了二级缓存，则查询顺序为："),e("strong",[t._v("二级缓存 → 一级缓存 → 数据库")]),t._v("。")]),t._v(" "),e("h3",{attrs:{id:"一级缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一级缓存"}},[t._v("#")]),t._v(" 一级缓存")]),t._v(" "),e("p",[t._v("一级缓存 mybatis 已近为我们自动开启，不用我们手动操作，而且我们是关闭不了的，但是我们可以手动清除缓存。执行查询时，SqlSession 是将任务交给 Executor 来完成对数据库的各种操作，所以在 Executor 查询前，会先去查询缓存。")]),t._v(" "),e("p",[t._v("一级缓存在 PerpetualCache 中维护一个叫 cache 的 HashMap 来进行缓存的存储：")]),t._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Map")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" cache "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HashMap")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("p",[t._v("根据 statementId 、 rowBounds 、传递给 JDBC 的 SQL 和 rowBounds.limit 决定 key 中的 hashcode。因此，相同的操作就会有相同的 hashcode，来保证一个 cacheKey 对应一个操作。")]),t._v(" "),e("p",[t._v("总结：当查询相同的结果时，就会使用一级缓存。")]),t._v(" "),e("h3",{attrs:{id:"二级缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二级缓存"}},[t._v("#")]),t._v(" 二级缓存")]),t._v(" "),e("p",[t._v("当我们的配置文件"),e("strong",[t._v("mybatis-config.xml")]),t._v(" 配置了"),e("strong",[t._v("cacheEnabled=true")]),t._v("时，就会开启二级缓存，二级缓存是 mapper 级别的，也就说不同的 sqlsession 使用同一个 mapper 查询是，查询到的数据可能是另一个 sqlsession 做相同操作留下的缓存。")]),t._v(" "),e("p",[t._v("SqlSession 对象创建 Executor 对象时，会对 Executor 对象加上一个装饰者：CachingExecutor，然后将操作数据库的任务交给 CachingExecutor，此时 CachingExecutor 会查找二级缓存是否有需要的数据，如果没有则将任务交给 Executor 对象。数据将会存放在 Configuration 中。")]),t._v(" "),e("p",[t._v("当在其他的 Session 中执行增删改操作时，二级缓存会被清空。")]),t._v(" "),e("p",[e("strong",[t._v("开启场景：")])]),t._v(" "),e("ol",[e("li",[t._v("因为所有的增删改都会刷新二级缓存，导致二级缓存失效，所以适合在"),e("strong",[t._v("查询")]),t._v("为主的应用中使用，比如历史交易、历史订单的查询。否则缓存就失去了意义。")]),t._v(" "),e("li",[t._v("如果多个 namespace 中有针对于同一个表的操作，比如 Blog 表，如果在一个 namespace 中刷新了缓存，另一个 namespace 中没有刷新，就会出现读到"),e("strong",[t._v("脏数据")]),t._v("的情况。所以，推荐在一个 Mapper 里面只操作"),e("strong",[t._v("单表")]),t._v("的情况使用。")])])])}),[],!1,null,null,null);s.default=v.exports}}]);