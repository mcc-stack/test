(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{364:function(A,v){A.exports="data:image/png;base64,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"},365:function(A,v,t){A.exports=t.p+"assets/img/image-20200303155442430.d6696bf1.png"},366:function(A,v,t){A.exports=t.p+"assets/img/image-20200303160346665.927858a4.png"},367:function(A,v,t){A.exports=t.p+"assets/img/image-20200303160602737.b0ee65ab.png"},368:function(A,v,t){A.exports=t.p+"assets/img/image-20200303170120474.d3a628f5.png"},369:function(A,v,t){A.exports=t.p+"assets/img/image-20200303170311646.d59a6960.png"},370:function(A,v,t){A.exports=t.p+"assets/img/image-20200303170551356.120ecc66.png"},416:function(A,v,t){"use strict";t.r(v);var _=t(42),a=Object(_.a)({},(function(){var A=this,v=A.$createElement,_=A._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":A.$parent.slotKey}},[_("h1",{attrs:{id:"mysql"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[A._v("#")]),A._v(" MySQL")]),A._v(" "),_("h2",{attrs:{id:"事务四大特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务四大特性"}},[A._v("#")]),A._v(" 事务四大特性")]),A._v(" "),_("ul",[_("li",[_("p",[A._v("原子性")]),A._v(" "),_("p",[A._v("原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。可以通过"),_("strong",[A._v("undo log")]),A._v("来保证原子性。")])]),A._v(" "),_("li",[_("p",[A._v("一致性")]),A._v(" "),_("p",[A._v("事务前后数据的完整性必须保持一致。可以通过"),_("strong",[A._v("undo log+redo log")]),A._v("来保证一致性。")])]),A._v(" "),_("li",[_("p",[A._v("隔离性")]),A._v(" "),_("p",[A._v("事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。可以通过"),_("strong",[A._v("锁")]),A._v("来保证隔离性。")])]),A._v(" "),_("li",[_("p",[A._v("持久性")]),A._v(" "),_("p",[A._v("持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。可以通过"),_("strong",[A._v("redo log")]),A._v("来保证持久性。")])])]),A._v(" "),_("h2",{attrs:{id:"事务隔离级别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离级别"}},[A._v("#")]),A._v(" 事务隔离级别")]),A._v(" "),_("table",[_("thead",[_("tr",[_("th",[A._v("隔离级别")]),A._v(" "),_("th",[A._v("脏读")]),A._v(" "),_("th",[A._v("不可重复读")]),A._v(" "),_("th",[A._v("幻读")])])]),A._v(" "),_("tbody",[_("tr",[_("td",[A._v("读未交读（Read uncommitted）")]),A._v(" "),_("td",[A._v("可能")]),A._v(" "),_("td",[A._v("可能")]),A._v(" "),_("td",[A._v("可能")])]),A._v(" "),_("tr",[_("td",[A._v("提交读（Read committed）")]),A._v(" "),_("td",[A._v("不可能")]),A._v(" "),_("td",[A._v("可能")]),A._v(" "),_("td",[A._v("可能")])]),A._v(" "),_("tr",[_("td",[A._v("可重复读（Repeatable read）")]),A._v(" "),_("td",[A._v("不可能")]),A._v(" "),_("td",[A._v("不可能")]),A._v(" "),_("td",[A._v("可能")])]),A._v(" "),_("tr",[_("td",[A._v("串行化（Serializable ）")]),A._v(" "),_("td",[A._v("不可能")]),A._v(" "),_("td",[A._v("不可能")]),A._v(" "),_("td",[A._v("不可能")])])])]),A._v(" "),_("ul",[_("li",[_("p",[A._v("脏读")]),A._v(" "),_("p",[A._v("一个事务读取到了另外一个事务没有提交的数据。主要作用于 select。")]),A._v(" "),_("p",[_("strong",[A._v("例子：")]),A._v(" 事务 T1 更新了一行记录的内容，但是并没有提交所做的修改。事务 T2 读取到了 T1 更新后的行，然后 T1 执行回滚操作，取消了刚才所做的修改。现在 T2 所读取的行就无效了。")]),A._v(" "),_("p",[_("strong",[A._v("解决：")]),A._v(" 修改时加"),_("strong",[A._v("排他锁")]),A._v("，直到事务提交后才释放，读取时加共享锁。当一个事务进行修改时，其他事务只能读取到该数据的快照。")])]),A._v(" "),_("li",[_("p",[A._v("不可重复读")]),A._v(" "),_("p",[A._v("在同一事务中，两次读取同一数据，得到内容不同。主要作用于 update。")]),A._v(" "),_("p",[_("strong",[A._v("例子：")]),A._v(" 事务 T1 读取一行记录，紧接着事务 T2 修改了 T1 刚才读取的那一行记录。然后 T1 又再次读取这行记录，发现与刚才读取的结果不同。这就称为“不可重复”读，因为 T1 原来读取的那行记录已经发生了变化。")]),A._v(" "),_("p",[_("strong",[A._v("解决：")]),A._v(" 使用 MVCC，由于每个事务都有一个版本号，当 T2 修改了数据，但是版本号比 T1 大，所以，T1 还是会读到原来的数据。")])]),A._v(" "),_("li",[_("p",[A._v("幻读")]),A._v(" "),_("p",[A._v("同一事务中，用同样的操作读取两次，得到的记录数不相同。主要作用与 DELETE 和 INSERT。")]),A._v(" "),_("p",[_("strong",[A._v("例子：")]),A._v(" 事务 T1 读取一条指定的 WHERE 子句所返回的结果集。然后事务 T2 新插入 一行记录，这行记录恰好可以满足 T1 所使用的查询条件中的 WHERE 子句的条件。然后 T1 又使用相同的查询再次对表进行检索，但是此时却看到了事务 T2 刚才插入的新行。这个新行就称为“幻像”，因为对 T1 来说这一行就像突然出现的一样。")]),A._v(" "),_("p",[_("strong",[A._v("解决：")]),A._v(" 将事务串行化，一个个执行。但是效率极其低下。")])])]),A._v(" "),_("h2",{attrs:{id:"innodb-和-myisam-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#innodb-和-myisam-的区别"}},[A._v("#")]),A._v(" Innodb 和 MyISAM 的区别")]),A._v(" "),_("table",[_("thead",[_("tr",[_("th"),A._v(" "),_("th",[A._v("InnoDB")]),A._v(" "),_("th",[A._v("MyISAM")])])]),A._v(" "),_("tbody",[_("tr",[_("td",[A._v("特点")]),A._v(" "),_("td",[A._v("支持事务，行锁，外键，非锁定读")]),A._v(" "),_("td",[A._v("不支持事务，支持表锁，全文索引，缓冲池只缓存索引文件")])]),A._v(" "),_("tr",[_("td",[A._v("适合操作")]),A._v(" "),_("td",[A._v("适合大量的增删操作，因为行锁粒度比表锁更小")]),A._v(" "),_("td",[A._v("大量 select（1、myisam 不缓存数据块，只缓存索引块；2、myisam 记录的直接是文件的 OFFSET，定位比 INNODB 要快，INNODB 是映射到块，再映射到行；3、INNODB 需要维护 MVCC）")])]),A._v(" "),_("tr",[_("td",[A._v("高并发性")]),A._v(" "),_("td",[A._v("有 MVCC，并发性很高")]),A._v(" "),_("td",[A._v("并发性低")])]),A._v(" "),_("tr",[_("td",[A._v("索引")]),A._v(" "),_("td",[A._v("聚集索引，B+树结构，必须有主键；辅助索引需要查询两次，因此查询速度不如 MyISAM；索引和数据文件捆绑")]),A._v(" "),_("td",[A._v("非聚集索引，B+树结构，可以没有主键；索引和数据文件分离，索引保存的是数据文件的指针；主键索引和辅助索引独立")])]),A._v(" "),_("tr",[_("td",[A._v("文件")]),A._v(" "),_("td",[A._v("frm 存放表定义内容，idb 存放数据")]),A._v(" "),_("td",[A._v("frm 存放表定义内容，myd 存放数据，myi 存放索引")])]),A._v(" "),_("tr",[_("td",[A._v("特性")]),A._v(" "),_("td",[A._v("插入缓冲、二次写、自适应哈希、预读")]),A._v(" "),_("td",[A._v("/")])]),A._v(" "),_("tr",[_("td",[A._v("使用场景")]),A._v(" "),_("td",[A._v("OLTP（联机事务处理），主要是执行基本日常的事务处理")]),A._v(" "),_("td",[A._v("OLAP（联机分析处理），数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果，数据量大")])])])]),A._v(" "),_("h2",{attrs:{id:"锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[A._v("#")]),A._v(" 锁")]),A._v(" "),_("p",[_("img",{attrs:{src:t(364),alt:"image-20200303153635120"}})]),A._v(" "),_("p",[A._v("其中 IS 和 IX 代表意向共享锁和意向排他锁，是表级的锁。")]),A._v(" "),_("h3",{attrs:{id:"共享锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#共享锁"}},[A._v("#")]),A._v(" 共享锁")]),A._v(" "),_("p",[A._v("又称读锁，读取操作创建的锁。")]),A._v(" "),_("p",[A._v("一旦上锁，任何事务（包括当前事务）无法对其修改，其他事务可以并发读取数据，也可在对此数据再加共享锁。")]),A._v(" "),_("p",[A._v("语法："),_("code",[A._v("SELECT ... LOCK IN SHARE MODE;")])]),A._v(" "),_("h3",{attrs:{id:"排他锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#排他锁"}},[A._v("#")]),A._v(" 排他锁")]),A._v(" "),_("p",[A._v("又称写锁，如果事务对数据 A 加上排他锁后，则其他事务不可并发读取数据，也不能再对 A 加任何类型的锁。获准排他锁的事务既能读数据，又能修改数据。")]),A._v(" "),_("p",[A._v("语法："),_("code",[A._v("SELECT ... FOR UPDATE")])]),A._v(" "),_("h3",{attrs:{id:"意向锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#意向锁"}},[A._v("#")]),A._v(" 意向锁")]),A._v(" "),_("p",[A._v("意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的 IS 锁。")]),A._v(" "),_("p",[A._v("意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的 IX 锁。")]),A._v(" "),_("p",[_("strong",[A._v("意向锁是 InnoDB 自动加的，不需要用户干预。")])]),A._v(" "),_("h2",{attrs:{id:"mvcc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mvcc"}},[A._v("#")]),A._v(" MVCC")]),A._v(" "),_("p",[A._v("mvcc 是多版本并发控制，是乐观锁的一种实现方式。它的实现是通过保存数据在某个时间点的快照，意味着事务无论运行多长时间，看到的数据都是相同的。")]),A._v(" "),_("p",[A._v("每一行数据中保存两个隐藏列，当前行"),_("strong",[A._v("创建时")]),A._v("的版本号和"),_("strong",[A._v("删除时")]),A._v("的版本号。当开始新的事务的时候，版本号都会增加。我们可以通过版本号来控制数据。查询时要求：删除版本号大于当前事务版本号，创建版本号小于等于当前事务版本号。")]),A._v(" "),_("p",[A._v("只适用于读已提交与可重复读。读未提交会有脏读，总能读取到事务的最新版本，而序列化总是锁定行。")]),A._v(" "),_("h2",{attrs:{id:"索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[A._v("#")]),A._v(" 索引")]),A._v(" "),_("p",[A._v("索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。以下是不同的存储引擎支持的索引结构：")]),A._v(" "),_("p",[_("img",{attrs:{src:t(365),alt:"image-20200303155442430"}})]),A._v(" "),_("p",[A._v("每个存储引擎支持的索引类型都不一样，但是值得一提的是，InnoDB 其实是会支持哈希索引的，但是是自适应哈希索引。")]),A._v(" "),_("p",[A._v("创建索引的语句如下：")]),A._v(" "),_("p",[_("code",[A._v("CREATE INDEX index_name ON table_name ( column )")])]),A._v(" "),_("p",[_("code",[A._v("ALTER TABLE table_name ADD INDEX index_name ( column )")])]),A._v(" "),_("h3",{attrs:{id:"哈希索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#哈希索引"}},[A._v("#")]),A._v(" 哈希索引")]),A._v(" "),_("p",[A._v("哈希索引（hash index）基于"),_("strong",[A._v("哈希表")]),A._v("实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。")]),A._v(" "),_("p",[A._v("对于 hash 相同的，采用拉链法的方式解决冲突。其中解决哈希冲突的方法如下：")]),A._v(" "),_("ul",[_("li",[_("p",[A._v("开放地址法")]),A._v(" "),_("p",[A._v("线性探测、再平方探测等，根据一定的算法，在接下来的空位置找到地方存储。")])]),A._v(" "),_("li",[_("p",[A._v("拉链法")]),A._v(" "),_("p",[A._v("对于相同的哈希值，使用链表进行连接，使用数组存储每一个链表。")])]),A._v(" "),_("li",[_("p",[A._v("再哈希法")]),A._v(" "),_("p",[A._v("对于冲突的哈希值再次进行哈希处理，直至没有哈希冲突。")])])]),A._v(" "),_("h3",{attrs:{id:"b-树索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#b-树索引"}},[A._v("#")]),A._v(" B+树索引")]),A._v(" "),_("p",[A._v("B+树特征：")]),A._v(" "),_("ul",[_("li",[A._v("有 n 个子树的中间节点包含 n 个元素，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。")]),A._v(" "),_("li",[A._v("所有叶子节点包含元素的信息以及指向记录的指针，且叶子节点按关键字自小到大顺序链接。")]),A._v(" "),_("li",[A._v("所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。")])]),A._v(" "),_("p",[_("img",{attrs:{src:t(366),alt:"image-20200303160346665"}})]),A._v(" "),_("h4",{attrs:{id:"聚集索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#聚集索引"}},[A._v("#")]),A._v(" 聚集索引")]),A._v(" "),_("p",[A._v("聚集索引是按表的主键构造的 B+树，叶子节点存放的为整张表的行记录数据，每张表只能有一个聚集索引。优化器更倾向采用聚集索引，因为直接就能获取行数据。")]),A._v(" "),_("p",[A._v("要用自增 id 来做主键，不要非空列，避免出现大量分页碎片。")]),A._v(" "),_("h4",{attrs:{id:"辅助索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#辅助索引"}},[A._v("#")]),A._v(" 辅助索引")]),A._v(" "),_("p",[A._v("辅助索引也叫非聚集索引，叶子节点除了键值以外还包含了一个 bookmark，用来告诉 InnoDB 在哪里可以找到对应的行数据，InnoDB 的辅助索引的 bookmark 就是相对应行数据的聚集索引键。")]),A._v(" "),_("p",[A._v("也就是先获取指向主键索引的主键，然后通过主键索引来找到一个完整的行。如果辅助索引的树和聚集索引的树的高度都是 3，如果不是走主键索引走辅助索引的话，那么需要 6 次逻辑 IO 访问得到最终的数据页。辅助索引和聚集索引的概念关系图如下：")]),A._v(" "),_("p",[_("img",{attrs:{src:t(367),alt:"image-20200303160602737"}})]),A._v(" "),_("blockquote",[_("p",[_("strong",[A._v("B+树相对于 B 树的优点？")])]),A._v(" "),_("ul",[_("li",[A._v("单一节点存储更多的元素，使得查询的 IO 次数更少；")]),A._v(" "),_("li",[A._v("所有查询都要查找到叶子节点，查询性能稳定；")]),A._v(" "),_("li",[A._v("所有叶子节点形成有序链表，便于范围查询。")])]),A._v(" "),_("p",[_("strong",[A._v("为什么不使用红黑树？")])]),A._v(" "),_("p",[A._v("红黑树的深度往往比 B+树大很多，可能会造成磁盘 IO 读写过于频繁，导致效率低下。")]),A._v(" "),_("p",[A._v("数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。")]),A._v(" "),_("p",[A._v("为了达到这个目的，在实际实现 B-Tree 还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个 node 只需一次 I/O。")]),A._v(" "),_("p",[_("strong",[A._v("为什么不使用哈希表？")])]),A._v(" "),_("p",[A._v("虽然哈希表查找元素最快，但它有以下缺点：")]),A._v(" "),_("ul",[_("li",[A._v("hash 表只能匹配是否相等，不能实现范围查找；")]),A._v(" "),_("li",[A._v("当需要按照索引进行 order by 时，hash 值没办法支持排序；")]),A._v(" "),_("li",[A._v("无法使用组合索引的功能；")]),A._v(" "),_("li",[A._v("数据量很大时，哈希冲突会比较严重。")])])]),A._v(" "),_("h2",{attrs:{id:"回表查询与覆盖索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#回表查询与覆盖索引"}},[A._v("#")]),A._v(" 回表查询与覆盖索引")]),A._v(" "),_("h3",{attrs:{id:"回表查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#回表查询"}},[A._v("#")]),A._v(" 回表查询")]),A._v(" "),_("p",[A._v("所谓的回表查询就是指"),_("strong",[A._v("辅助索引")]),A._v("的查询过程，第一步先定位主键值，再查找行记录，性能比扫一遍索引树更低。")]),A._v(" "),_("h3",{attrs:{id:"覆盖索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#覆盖索引"}},[A._v("#")]),A._v(" 覆盖索引")]),A._v(" "),_("p",[A._v("索引覆盖是一种避免回表查询的优化策略。如果一个索引覆盖（包含）了所有需要查询的字段的值，这个索引就是覆盖索引。查询时可以直接返回索引中的的数据，不需要再通过聚集索引去定位行记录，避免了回表的情况发生。")]),A._v(" "),_("p",[A._v("当使用了覆盖索引后，explain 中的 Extra 列会提示 Using Index。")]),A._v(" "),_("h2",{attrs:{id:"避免全表扫描-索引失效"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#避免全表扫描-索引失效"}},[A._v("#")]),A._v(" 避免全表扫描/索引失效")]),A._v(" "),_("ul",[_("li",[A._v("用 or 分隔开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么都不会用到索引")]),A._v(" "),_("li",[A._v("以%开头的 LIKE 查询不能够利用 B-Tree 索引")]),A._v(" "),_("li",[A._v("复合索引的情况下，不满足最左原则，是不会使用复合索引的")]),A._v(" "),_("li",[A._v("如果 MySQL 估计使用索引比全表扫描更慢，则不适用索引")]),A._v(" "),_("li",[A._v("查询字段 is null 时索引失效")]),A._v(" "),_("li",[A._v("where 子句中使用"),_("code",[A._v("!=")]),A._v("与'<>'则索引失效")])]),A._v(" "),_("h3",{attrs:{id:"联合索引失效"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#联合索引失效"}},[A._v("#")]),A._v(" 联合索引失效")]),A._v(" "),_("ul",[_("li",[_("p",[A._v("where a=1 and b>1 and c=3;")]),A._v(" "),_("p",[A._v("c 不会用到索引。")])]),A._v(" "),_("li",[_("p",[A._v("where b=1 and c=1；")]),A._v(" "),_("p",[A._v("不符合最左原则，都不会用到索引。")])]),A._v(" "),_("li",[_("p",[A._v("where c=1 and b=1 and a=3;")]),A._v(" "),_("p",[A._v("优化器会自动优化顺序，实际上是会用到的。")])])]),A._v(" "),_("h2",{attrs:{id:"explain"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#explain"}},[A._v("#")]),A._v(" Explain")]),A._v(" "),_("p",[A._v("在查询条件之前加上 explain 关键词，可以有效分析 sql 语句的查询效率，explain 出来的信息有 10 列，如下：")]),A._v(" "),_("ul",[_("li",[A._v("id：选择标识符")]),A._v(" "),_("li",[A._v("select_type：表示查询的类型。")]),A._v(" "),_("li",[A._v("table：输出结果集的表")]),A._v(" "),_("li",[A._v("partitions：匹配的分区")]),A._v(" "),_("li",[A._v("type：表示表的连接类型")]),A._v(" "),_("li",[A._v("possible_keys：表示查询时，可能使用的索引")]),A._v(" "),_("li",[A._v("key：表示实际使用的索引")]),A._v(" "),_("li",[A._v("key_len：索引字段的长度")]),A._v(" "),_("li",[A._v("ref：列与索引的比较")]),A._v(" "),_("li",[A._v("rows：扫描出的行数(估算的行数)")]),A._v(" "),_("li",[A._v("filtered：按表条件过滤的行百分比")]),A._v(" "),_("li",[A._v("Extra：执行情况的描述和说明")])]),A._v(" "),_("h3",{attrs:{id:"select-type"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#select-type"}},[A._v("#")]),A._v(" select_type")]),A._v(" "),_("ul",[_("li",[A._v("SIMPLE：简单表，即不适用表连接或子查询")]),A._v(" "),_("li",[A._v("PRIMARY：主查询，即外层的查询")]),A._v(" "),_("li",[A._v("UNION：第二个或者后面的查询语句")]),A._v(" "),_("li",[A._v("SUBQUERY：子查询中的第一个 SELECT 等")])]),A._v(" "),_("h3",{attrs:{id:"type"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#type"}},[A._v("#")]),A._v(" type")]),A._v(" "),_("ul",[_("li",[A._v("ALL：全表扫描")]),A._v(" "),_("li",[A._v("index：索引全扫描")]),A._v(" "),_("li",[A._v("range：索引范围扫描，常见于<，<=，>，>=，between 等操作符")]),A._v(" "),_("li",[A._v("ref：非唯一索引扫描或唯一索引的前缀扫描，返回匹配某个单独值的记录行(也会出现在 join 操作中)")]),A._v(" "),_("li",[A._v("eq_ref：唯一索引，每个索引键值，表中只有一条记录匹配，常出现于用主键作为查询条件的查询")]),A._v(" "),_("li",[A._v("const/system：单表中最多有一个匹配行，查询起来非常迅速，所以这个匹配行中的其他列的值被优化器在当前查询中当做常量来处理")]),A._v(" "),_("li",[A._v("null：不用访问表或者索引，直接就能够得到结果")])]),A._v(" "),_("p",[A._v("访问速度： null>system > const > eq_ref > ref > range > index > ALL。")]),A._v(" "),_("h3",{attrs:{id:"extra"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#extra"}},[A._v("#")]),A._v(" Extra")]),A._v(" "),_("ul",[_("li",[A._v("Using where：需要回表")]),A._v(" "),_("li",[A._v("Using index：不需要回表，覆盖索引")]),A._v(" "),_("li",[A._v("Using filesort：所有不是通过索引排序的数据都是 Filesort 排序，即要多进行一次排序")])]),A._v(" "),_("h2",{attrs:{id:"sql-语句执行顺序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sql-语句执行顺序"}},[A._v("#")]),A._v(" SQL 语句执行顺序")]),A._v(" "),_("ol",[_("li",[A._v("from")]),A._v(" "),_("li",[A._v("where")]),A._v(" "),_("li",[A._v("group by")]),A._v(" "),_("li",[A._v("having")]),A._v(" "),_("li",[A._v("select")]),A._v(" "),_("li",[A._v("order by")]),A._v(" "),_("li",[A._v("limit")])]),A._v(" "),_("h2",{attrs:{id:"三大范式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三大范式"}},[A._v("#")]),A._v(" 三大范式")]),A._v(" "),_("h3",{attrs:{id:"第一范式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第一范式"}},[A._v("#")]),A._v(" 第一范式")]),A._v(" "),_("p",[_("strong",[A._v("要求数据库表的每一列都是不可分割的原子数据项。")])]),A._v(" "),_("p",[_("img",{attrs:{src:t(368),alt:"image-20200303170120474"}})]),A._v(" "),_("p",[A._v("家庭信息和学校信息不满足第一范式。")]),A._v(" "),_("h3",{attrs:{id:"第二范式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第二范式"}},[A._v("#")]),A._v(" 第二范式")]),A._v(" "),_("p",[_("strong",[A._v("在 1NF 的基础上，非码属性必须完全依赖于候选码。")]),A._v(" 通俗讲，就是本应是两个表的内容并且没有任何关联，却塞到了一个表里。")]),A._v(" "),_("p",[_("img",{attrs:{src:t(369),alt:"image-20200303170311646"}})]),A._v(" "),_("p",[A._v("比如图中应将产品和订单分别做表。")]),A._v(" "),_("h3",{attrs:{id:"第三范式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第三范式"}},[A._v("#")]),A._v(" 第三范式")]),A._v(" "),_("p",[_("strong",[A._v("在 2NF 基础上，任何非主属性不依赖于其它非主属性")]),A._v("，通俗讲就是，应当拆成两个表，有一定的依赖关系，应当选一个属性作为原来表的外键。")]),A._v(" "),_("p",[_("img",{attrs:{src:t(370),alt:"image-20200303170551356"}})]),A._v(" "),_("p",[A._v("应当将图中的班主任相关信息单独成表，班主任姓名作为外键关联。")]),A._v(" "),_("h2",{attrs:{id:"left-join-right-join-inner-join-outer-join-的含义及区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#left-join-right-join-inner-join-outer-join-的含义及区别"}},[A._v("#")]),A._v(" left join,right join,inner join,outer join 的含义及区别")]),A._v(" "),_("ul",[_("li",[_("p",[A._v("left join")]),A._v(" "),_("p",[A._v("左外连接，就是把左边表的数据全部取出来，而右边表的数据有相等的，显示出来，如果没有，显示 NULL。")])]),A._v(" "),_("li",[_("p",[A._v("right join")]),A._v(" "),_("p",[A._v("就是把右边表的数据全部取出来，而左边表的数据有相等的，显示出来，如果没有，显示 NULL。")])]),A._v(" "),_("li",[_("p",[A._v("inner join")]),A._v(" "),_("p",[A._v("两个表的字段中的相同值，显示数据记录。")])]),A._v(" "),_("li",[_("p",[A._v("outer join")]),A._v(" "),_("p",[A._v("查询结果是左外连接和右外连接查询结果的并集，即使一些记录关联不上，也能够把部分信息查询出来，MySQL 不支持全连接，可以通过 union 查询。")])])])])}),[],!1,null,null,null);v.default=a.exports}}]);