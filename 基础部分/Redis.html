<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis | 533实验室Java后端知识点整理</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="533实验室Java后端知识点整理">
    <link rel="preload" href="/test/assets/css/0.styles.363e3238.css" as="style"><link rel="preload" href="/test/assets/js/app.fb04842c.js" as="script"><link rel="preload" href="/test/assets/js/2.275389a7.js" as="script"><link rel="preload" href="/test/assets/js/7.dc65d060.js" as="script"><link rel="prefetch" href="/test/assets/js/10.d306dbdb.js"><link rel="prefetch" href="/test/assets/js/11.3cb03267.js"><link rel="prefetch" href="/test/assets/js/12.913d7c94.js"><link rel="prefetch" href="/test/assets/js/13.888020c4.js"><link rel="prefetch" href="/test/assets/js/14.aa2ced95.js"><link rel="prefetch" href="/test/assets/js/15.17131c71.js"><link rel="prefetch" href="/test/assets/js/16.09c5f2c9.js"><link rel="prefetch" href="/test/assets/js/17.b5fb47e1.js"><link rel="prefetch" href="/test/assets/js/18.a85f24aa.js"><link rel="prefetch" href="/test/assets/js/19.e62c702b.js"><link rel="prefetch" href="/test/assets/js/20.de5fd22c.js"><link rel="prefetch" href="/test/assets/js/21.43f72dd9.js"><link rel="prefetch" href="/test/assets/js/22.ea2b70ef.js"><link rel="prefetch" href="/test/assets/js/23.0dbebaf7.js"><link rel="prefetch" href="/test/assets/js/24.37c84f01.js"><link rel="prefetch" href="/test/assets/js/25.1104c8a2.js"><link rel="prefetch" href="/test/assets/js/3.44c5d363.js"><link rel="prefetch" href="/test/assets/js/4.a42ed78f.js"><link rel="prefetch" href="/test/assets/js/5.5558f3f5.js"><link rel="prefetch" href="/test/assets/js/6.af04c27c.js"><link rel="prefetch" href="/test/assets/js/8.25a2093a.js"><link rel="prefetch" href="/test/assets/js/9.2e34f20e.js">
    <link rel="stylesheet" href="/test/assets/css/0.styles.363e3238.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/test/" class="home-link router-link-active"><!----> <span class="site-name">533实验室Java后端知识点整理</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/test/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/lamarsan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/test/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/lamarsan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>基础部分</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/基础部分/操作系统.html" class="sidebar-link">操作系统</a></li><li><a href="/test/基础部分/Linux.html" class="sidebar-link">Linux</a></li><li><a href="/test/基础部分/计算机网络.html" class="sidebar-link">计算机网络</a></li><li><a href="/test/基础部分/JavaSE.html" class="sidebar-link">Java SE</a></li><li><a href="/test/基础部分/JVM.html" class="sidebar-link">JVM</a></li><li><a href="/test/基础部分/多线程并发.html" class="sidebar-link">多线程并发</a></li><li><a href="/test/基础部分/Mysql.html" class="sidebar-link">MySQL</a></li><li><a href="/test/基础部分/Redis.html" class="active sidebar-link">Redis</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#使用场景" class="sidebar-link">使用场景</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#分布式缓存和本地缓存的区别" class="sidebar-link">分布式缓存和本地缓存的区别</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#redis-通信协议" class="sidebar-link">Redis 通信协议</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#redis-和-memcache-的区别" class="sidebar-link">Redis 和 Memcache 的区别</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#常用数据结构" class="sidebar-link">常用数据结构</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#zset-底层实现" class="sidebar-link">zset 底层实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#跳跃表的搜索" class="sidebar-link">跳跃表的搜索</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#跳跃表的插入" class="sidebar-link">跳跃表的插入</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#跳跃表的删除" class="sidebar-link">跳跃表的删除</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#过期删除策略" class="sidebar-link">过期删除策略</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#内存淘汰机制" class="sidebar-link">内存淘汰机制</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#持久化机制" class="sidebar-link">持久化机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#rdb" class="sidebar-link">RDB</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#aof" class="sidebar-link">AOF</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#redis-事务" class="sidebar-link">Redis 事务</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#相关命令" class="sidebar-link">相关命令</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#注意点" class="sidebar-link">注意点</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#redis-pipeline" class="sidebar-link">Redis Pipeline</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#使用场景-2" class="sidebar-link">使用场景</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#与批量命令的区别" class="sidebar-link">与批量命令的区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#三大缓存问题" class="sidebar-link">三大缓存问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#缓存穿透" class="sidebar-link">缓存穿透</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#缓存雪崩" class="sidebar-link">缓存雪崩</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#缓存击穿" class="sidebar-link">缓存击穿</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#缓存更新策略" class="sidebar-link">缓存更新策略</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#先更新数据库-再更新缓存" class="sidebar-link">先更新数据库，再更新缓存</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#先删除缓存-再更新数据库" class="sidebar-link">先删除缓存，再更新数据库</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#先更新数据库-再删除缓存" class="sidebar-link">先更新数据库，再删除缓存</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#redis-为什么快" class="sidebar-link">Redis 为什么快</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#五种-io-模型" class="sidebar-link">五种 IO 模型</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#redis-的-io-多路复用" class="sidebar-link">Redis 的 IO 多路复用</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#热点-key-问题" class="sidebar-link">热点 key 问题</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#redis-数据分布" class="sidebar-link">Redis 数据分布</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#redis-集群结构" class="sidebar-link">Redis 集群结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#主从复制" class="sidebar-link">主从复制</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#哨兵模式" class="sidebar-link">哨兵模式</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/Redis.html#redis-cluster" class="sidebar-link">Redis Cluster</a></li></ul></li></ul></li><li><a href="/test/基础部分/源码.html" class="sidebar-link">源码</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架部分</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>大数据</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>项目</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="redis"><a href="#redis" class="header-anchor">#</a> Redis</h1> <h2 id="使用场景"><a href="#使用场景" class="header-anchor">#</a> 使用场景</h2> <ul><li><p>数据（热点）⾼并发的读写</p></li> <li><p>海量数据的读写</p></li> <li><p>对扩展性要求⾼的数据</p></li></ul> <h2 id="分布式缓存和本地缓存的区别"><a href="#分布式缓存和本地缓存的区别" class="header-anchor">#</a> 分布式缓存和本地缓存的区别</h2> <table><thead><tr><th></th> <th>分布式缓存</th> <th>本地缓存</th></tr></thead> <tbody><tr><td>缓存一致性</td> <td>较好</td> <td>较弱，每个实例都有自己的缓存</td></tr> <tr><td>堆内存占用</td> <td>不占用</td> <td>占用，影响垃圾回收</td></tr> <tr><td>速度</td> <td>较慢，因为需要网络传输和序列化</td> <td>较快</td></tr> <tr><td>使用场景</td> <td>要求数据一致性，访问量大的场景</td> <td>对数据一致性没有特别高的要求，且访问次数多的场景</td></tr></tbody></table> <p>本地缓存的实现：</p> <ul><li>使用特定数据结构，比如 ConcurrentHashMap</li> <li>使⽤开源的缓存框架 Ehcache，Ehcache 封装了对于内存操作的功能</li> <li>Guava Cache 是 Google 开源的⼯具集， 提供了缓存的边界操作⼯具</li></ul> <h2 id="redis-通信协议"><a href="#redis-通信协议" class="header-anchor">#</a> Redis 通信协议</h2> <p>Redis 的通信协议是 Redis Serialization Protocol，简称 RESP。</p> <p>特征如下：</p> <ol><li>二进制安全</li> <li>在 TCP 层</li> <li>基于请求-响应的模式</li></ol> <h2 id="redis-和-memcache-的区别"><a href="#redis-和-memcache-的区别" class="header-anchor">#</a> Redis 和 Memcache 的区别</h2> <table><thead><tr><th></th> <th>Redis</th> <th>Memcache</th></tr></thead> <tbody><tr><td>存储方式</td> <td>持久化</td> <td>断电丢失</td></tr> <tr><td>支持数据类型不同</td> <td>String,hash,list,set,zset</td> <td>只支持 key-value</td></tr> <tr><td>速度</td> <td>快</td> <td>慢</td></tr></tbody></table> <h2 id="常用数据结构"><a href="#常用数据结构" class="header-anchor">#</a> 常用数据结构</h2> <ul><li><p>String（字符串）</p> <p>最大容量为 512M</p></li> <li><p>list（列表）</p> <p>list 是字符串列表，按照插⼊顺序排序。元素可以在列表的头部（左边）或者尾部（右边）进⾏添加。最大容量为 2^32-1 个。可以做消息队列。</p></li> <li><p>hash（哈希）</p> <p>Redis hash 是⼀个键值对（key-value）集合。Redis hash 是⼀个 String 类型的 field 和 value 的映射表，hash 特别适合⽤于存储对象。最大容量为 2^32-1 个。</p></li> <li><p>set（集合）</p> <p>Redis 的 set 是 String 类型的⽆序集合。最大容量为 2^32-1 个。</p></li> <li><p>zset（sorted set：有序集合）</p> <p>Redis zset 和 set ⼀样也是 String 类型元素的集合，且 不允许重复的成员。不同的 zset 是每个元素都会关联⼀个 double 类型的分数。zset 通过这个分数来为集合中所有元素进⾏从⼩到⼤的排序。zset 的成员是唯⼀的，但分数（score）却可以重复。最大容量为 2^32-1 个。适合做排行榜。</p></li></ul> <h2 id="zset-底层实现"><a href="#zset-底层实现" class="header-anchor">#</a> zset 底层实现</h2> <p>zset 有两种实现，分别是 ziplist 或 skiplist。</p> <p>只有当保存的元素数量小于 128，并且保存的所有元素长度都小于 64 字节才会使用压缩列表，否则使用跳跃表。</p> <ul><li><p>ziplist</p> <p>ziplist 所有元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个保存分值。并且集合元素按照分值从小到大顺序排列，小的靠近表头，大的放置在表尾。</p></li> <li><p>skiplist</p> <p>一个结构同时会包含一个字典和一个跳跃表，字典的键保存元素的值，字典的值保存元素的分值；跳跃表节点的 object 属性保存元素的成员，score 属性保存元素的分值。</p> <p>跳表具有如下性质：</p> <ol><li>由很多层结构组成</li> <li>每一层都是一个有序的链表</li> <li>最底层(Level 1)的链表包含所有元素</li> <li>如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。</li> <li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</li></ol> <p><img src="/test/assets/img/image-20200303203914508.6a1bc540.png" alt="image-20200303203914508"></p></li></ul> <h3 id="跳跃表的搜索"><a href="#跳跃表的搜索" class="header-anchor">#</a> 跳跃表的搜索</h3> <p><img src="/test/assets/img/image-20200303204101087.63192902.png" alt="image-20200303204101087"></p> <p>例子：查找元素 117</p> <ol><li>比较 21， 比 21 大，往后面找</li> <li>比较 37, 比 37 大，比链表最大值小，从 37 的下面一层开始找</li> <li>比较 71, 比 71 大，比链表最大值小，从 71 的下面一层开始找</li> <li>比较 85， 比 85 大，从后面找</li> <li>比较 117， 等于 117， 找到了节点。</li></ol> <p>先从最顶层开始往右找，大于最大值后就往下找。</p> <h3 id="跳跃表的插入"><a href="#跳跃表的插入" class="header-anchor">#</a> 跳跃表的插入</h3> <p>先确定元素需要占据的层数 K，由抛硬币决定，是正面就继续抛；然后在 1-K 层都插入这个元素；如果 K 大于当前层数最大值，则添加新的层。</p> <h3 id="跳跃表的删除"><a href="#跳跃表的删除" class="header-anchor">#</a> 跳跃表的删除</h3> <p>各个层中找到包含 x 的节点，使用 delete from list 方法删除节点。</p> <h2 id="过期删除策略"><a href="#过期删除策略" class="header-anchor">#</a> 过期删除策略</h2> <p>常见的删除策略：</p> <ul><li>定时删除：设置过期时间的同时，创建一个 timer，过期时间一到就主动删除</li> <li>惰性删除：放任不管，每次获取时，才判断是否过期，过期就删除，属于被动删除</li> <li>定期删除：每隔一段时间就对数据库进行一次删除过期键的操作</li></ul> <p>Redis 采用惰性删除+定期删除的方式管理键。既减小 cpu 压力的同时，也保证了数据的准确性。</p> <h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="header-anchor">#</a> 内存淘汰机制</h2> <p>由于可能发生，既没有被惰性删除也没有被定期删除，但内存很快满了的情况出现，所以需要一定的内存淘汰机制。有 6 中淘汰策略：</p> <ul><li>no-eviction：不会继续服务<strong>写请求</strong>，<strong>读请求</strong>可以继续进行。这样可以保证不会丢失数据，但是会让线上的业务不能持续进行。这是默认的淘汰策略。</li> <li>volatile-lru：尝试<strong>淘汰设置了过期时间</strong>的 key，最少使用的 key 优先被淘汰。没有设置过期时间的 key 不会被淘汰，这样可以保证需要持久化的数据不会突然丢失。（这个是使用最多的）</li> <li>volatile-ttl：跟上面一样，除了淘汰的策略不是 LRU，而是 key 的剩余寿命 ttl 的值，ttl 越小越优先被淘汰,即<strong>淘汰将要过期的数据</strong>。</li> <li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中<strong>随机</strong>选择数据淘汰。</li> <li>allkeys-lru：区别于 volatile-lru，这个策略要淘汰的 key 对象是全体的 key 集合，而不只是过期的 key 集合。这意味着没有设置过期时间的 key 也会被淘汰。</li> <li>allkeys-random：从全体的 key 集合（server.db[i].dict）中任意选择数据淘汰。</li></ul> <h2 id="持久化机制"><a href="#持久化机制" class="header-anchor">#</a> 持久化机制</h2> <ul><li>RDB：将 Redis 在内存中的数据库记录定时 dump 到磁盘上的 RDB 持久化。</li> <li>AOF：将 Redis 的操作日志以追加的方式写入文件。</li></ul> <h3 id="rdb"><a href="#rdb" class="header-anchor">#</a> RDB</h3> <p>RDB 持久化是指在指定的时间间隔内将内存中的数据集快照写⼊磁盘，实际操作过程是 fork ⼀个⼦进程，先将数据集写⼊临时⽂件，写⼊成功后，再替换之前的⽂件，⽤⼆进制压缩存储。</p> <p>优点：</p> <ol><li><p>RDB 是紧凑的⼆进制⽂件，⽐较适合备份，全量复制等场景</p></li> <li><p>RDB 恢复数据远快于 AOF</p></li></ol> <p>缺点：</p> <ol><li>无法实现实时或者秒级持久化</li> <li>新老版本无法兼容 RDB</li></ol> <h3 id="aof"><a href="#aof" class="header-anchor">#</a> AOF</h3> <p>AOF 持久化以⽇志的形式记录服务器所处理的每⼀个写、删除操作，查询操作不会记录，以⽂本的⽅式记录，可以打开⽂件看到详细的操作记录。</p> <p>优点：</p> <ol><li>更好地保护数据不丢失</li> <li>append-only 模式写入性能比较高</li> <li>适合做灾难性的误删除紧急恢复</li></ol> <p>缺点：</p> <ol><li>对于同一份文件，AOF 文件要比 RDB 快照大</li> <li>会对 QPS 有所影响</li> <li>数据库恢复慢，不适合做冷备</li></ol> <h2 id="redis-事务"><a href="#redis-事务" class="header-anchor">#</a> Redis 事务</h2> <p>Redis 中的事务是⼀组命令的集合，是 Redis 的最⼩执⾏单位，⼀个事务要么都执⾏，要么都不执⾏；Reids 事务保证⼀个事务内的命令依次执⾏，⽽不会被其他命令插⼊；Redis 事务的原理是先将属于⼀个事务的命令发送给 Redis，然后依次执⾏这些命令。</p> <h3 id="相关命令"><a href="#相关命令" class="header-anchor">#</a> 相关命令</h3> <ol><li><p>discard 命令：取消事务，丢弃事务中所有命令。</p></li> <li><p>exec 命令：执⾏所有事务内的命令。</p></li> <li><p>multi 命令：标记⼀个事务开始。</p></li> <li><p>unwatch 命令：取消 watch 命令对所有 key 的监视。</p></li> <li><p>watch 命令：监视⼀个（或多个）key，如果在执⾏事务之前这个（这些）key 被其他命令所改动，事务将被打断。</p></li></ol> <h3 id="注意点"><a href="#注意点" class="header-anchor">#</a> 注意点</h3> <ol><li><p>不⽀持回滚，如果事务中有错误的操作，⽆法回滚到处理前的状态，需要开发者处理。</p></li> <li><p>在执⾏完当前事务内所有指令前，不会同时执⾏其他客户端的请求。</p></li></ol> <h2 id="redis-pipeline"><a href="#redis-pipeline" class="header-anchor">#</a> Redis Pipeline</h2> <p>Redis 客户端与服务端通信模型使⽤的 TCP 协议进⾏连接， 那么在单个指令的执⾏过程中，都 会存在“交互往返”的时间。 Redis 本身提供了一些批量命令，如 mget、mset，但不满足大部分命令，因此出现了 Pipeline。</p> <p>Pipeline 将一组 Redis 命令进行组装，一次性传输给 Redis，在讲这些命令执行结果，按照顺序返回客户端。</p> <h3 id="使用场景-2"><a href="#使用场景-2" class="header-anchor">#</a> 使用场景</h3> <p>有批量的数据写入 Reedis，并且允许一定比例的写入失败。</p> <h3 id="与批量命令的区别"><a href="#与批量命令的区别" class="header-anchor">#</a> 与批量命令的区别</h3> <ol><li>批量命令保证原子性，而 Pipeline 非原子。</li> <li>批量命令是一个命令对应多个 key，而 Pipeline 支持多个命令。</li> <li>批量命令是 Redis 服务端实现，Pipeline 需要服务端和客户端共同实现。</li></ol> <h2 id="三大缓存问题"><a href="#三大缓存问题" class="header-anchor">#</a> 三大缓存问题</h2> <h3 id="缓存穿透"><a href="#缓存穿透" class="header-anchor">#</a> 缓存穿透</h3> <p>查询缓存中没有，数据库也没有的数据会导致缓存穿透。</p> <p>解决方法：</p> <ul><li><p>布隆过滤</p> <p>将所有查询的参数都存储到一个 bitmap 中，查询之前先去 bitmap 里面验证，如果存在就进行底层缓存的数据查询；如果不存在就进行拦截。</p> <p>可以用于实现数据字典，进行数据的判重，集合求交集。</p></li> <li><p>缓存空对象</p> <p>直接缓存一个空对象，但是会有两个问题：</p> <ol><li>缓存将存储更多的键值对，可能会遭到恶意攻击，至于内存空间的浪费；可以通过设置过期时间来控制。</li> <li>DB 与缓存数据不一致，可以通过异步消息来进行数据更新的通知。</li></ol></li></ul> <h3 id="缓存雪崩"><a href="#缓存雪崩" class="header-anchor">#</a> 缓存雪崩</h3> <p>一段时间内，大量的缓存失效，导致数据库压力突然增大，导致缓存雪崩。</p> <p>解决方法：</p> <ul><li>分散失效时间</li> <li>DB 访问限制，进行限流</li> <li>多级缓存设计</li></ul> <h3 id="缓存击穿"><a href="#缓存击穿" class="header-anchor">#</a> 缓存击穿</h3> <p>缓存中没有，但是数据库中油的数据，这时由于并发用户多，就会造成数据库压力瞬间增大。</p> <p>解决方法：</p> <ol><li><p>设置热点数据永不过期</p></li> <li><p>加互斥锁，使写数据的只有一个线程执行：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token class-name">Lock</span> reenLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">getData04</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 从缓存读取数据</span>
    result <span class="token operator">=</span> <span class="token function">getDataFromCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>reenLock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我拿到锁了,从DB获取数据库后写入缓存&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 从数据库查询数据</span>
                result <span class="token operator">=</span> <span class="token function">getDataFromDB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 将查询到的数据写入缓存</span>
                <span class="token function">setDataToCache</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                reenLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 释放锁</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            result <span class="token operator">=</span> <span class="token function">getDataFromCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 先查一下缓存</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我没拿到锁,缓存也没数据,先小憩一下&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 小憩一会儿</span>
                <span class="token keyword">return</span> <span class="token function">getData04</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 重试</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ol> <h2 id="缓存更新策略"><a href="#缓存更新策略" class="header-anchor">#</a> 缓存更新策略</h2> <h3 id="先更新数据库-再更新缓存"><a href="#先更新数据库-再更新缓存" class="header-anchor">#</a> 先更新数据库，再更新缓存</h3> <ul><li><p>会导致线程安全问题</p> <p>两个线程一起更新数据，就会造成脏数据的问题。</p></li> <li><p>更新缓存的复杂度相对较高</p> <p>因为一般存入缓存的数据都要经过一系列的计算。</p></li></ul> <h3 id="先删除缓存-再更新数据库"><a href="#先删除缓存-再更新数据库" class="header-anchor">#</a> 先删除缓存，再更新数据库</h3> <p>可能会导致数据不一致的问题，比如，刚删掉缓存，另一个线程马上读取请求，缓存还是旧的。</p> <p>解决方法只能是写数据成功后，再更新一次缓存。</p> <h3 id="先更新数据库-再删除缓存"><a href="#先更新数据库-再删除缓存" class="header-anchor">#</a> 先更新数据库，再删除缓存</h3> <p>可能会造成短暂的数据不一致，在更新数据库成功后和删除缓存之前，会有一定的数据不一致现象，不过可以接受。</p> <h2 id="redis-为什么快"><a href="#redis-为什么快" class="header-anchor">#</a> Redis 为什么快</h2> <ul><li>数据都存放到了内存中</li> <li>Redis 是单线程的，也就意味着避免了不必要的上下文切换和竞争</li> <li>非阻塞 IO，内部采用 epoll，利用了 IO 多路复用的特性。</li></ul> <h3 id="五种-io-模型"><a href="#五种-io-模型" class="header-anchor">#</a> 五种 IO 模型</h3> <p>阻塞 I/O 模型、非阻塞 I/O 模型、I/O 复用模型、信号驱动 I/O 模型、异步 I/O 模型。</p> <h3 id="redis-的-io-多路复用"><a href="#redis-的-io-多路复用" class="header-anchor">#</a> Redis 的 IO 多路复用</h3> <p>IO 多路复用是指一个线程处理多个 IO 请求，redis 的网络事件处理器为文件事件处理器，它使用 IO 多路复用来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p> <p>当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。</p> <p><img src="/test/assets/img/image-20200103204756701.652d96ff.png" alt="image-20200103204756701"></p> <ul><li>如果是客户端要连接 redis，那么会为 socket 关联连接<strong>应答</strong>处理器</li> <li>如果是客户端要写入数据到 redis，那么会为 scoket 关联命令<strong>请求</strong>处理器</li> <li>如果是客户端要从 redis 读数据，那么会为 socket 关联命令<strong>回复</strong>处理器</li></ul> <h2 id="热点-key-问题"><a href="#热点-key-问题" class="header-anchor">#</a> 热点 key 问题</h2> <p>产生原因：</p> <ol><li>用户消费的数据远大于生产的数据，比如双十一的热门商品的促销</li> <li>请求分片集中，超过单 Server 的性能极限</li></ol> <p>导致危害：</p> <ol><li>流量集中，达到物理网卡上限</li> <li>请求过多，缓存分片服务被打垮</li> <li>DB 击穿，引起业务雪崩</li></ol> <p>解决方案：</p> <ol><li><p>使用 Memcache+Redis</p></li> <li><p>使用本地缓存</p></li> <li><p>读写分离</p></li></ol> <h2 id="redis-数据分布"><a href="#redis-数据分布" class="header-anchor">#</a> Redis 数据分布</h2> <ul><li><p>节点取余分区</p> <p>使用特定的数据，如 Redis 的键或用户的 ID，再根据公式：hash(key)%N，计算出 hash 值，用来决定数据落到那个节点。</p> <p>优点：简单，常用于分库分表。</p> <p>缺点：节点数量发生改变，映射关系需要重新计算。</p></li> <li><p>一致性 Hash 分区</p> <p>一致性 Hash 算法也是使用取模的方法，节点取余分区是对<strong>服务器的数量</strong>进行取模，而一致性 Hash 算法是对<strong>2^32</strong>取模。</p> <p>简单来说，一致性 Hash 算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数 H 的值空间为 0-2^32-1（即哈希值是一个 32 位无符号整形），整个哈希环如下：整个空间按顺时针方向组织，圆环的正上方的点代表 0，0 点右侧的第一个点代表 1，以此类推，2、3、4、5、6……直到 2^32-1，也就是说 0 点左侧的第一个点代表 2^32-1， 0 和 2^32-1 在零点中方向重合，我们把这个由 2^32 个点组成的圆环称为 Hash 环。</p> <p>下一步将各个服务器使用 Hash 进行一个哈希，具体可以选择服务器的 IP 或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。</p> <p><img src="/test/assets/img/image-20200303222700955.562cd364.png" alt="image-20200303222700955"></p> <p>优点：</p> <p>加入和删除节点只影响哈希环中相邻的节点，对其他节点没有影响。</p> <p>缺点：</p> <ol><li>需要手动处理因为节点改变而影响的数据，因此常用于缓存场景。</li> <li>不适合少量节点，因为它会影响大范围的节点映射。</li> <li>普通的一致性哈希分区在增减节点时需要增加一倍或减少一半节点才能保证数据和负载均衡。</li></ol></li> <li><p>虚拟槽分区</p> <p>虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中，整数定义为槽（slot）。</p> <p>Redis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 0-16383 整数槽内。</p> <p>计算公式：slot = CRC16(key)&amp;16383，每一个节点负责维护一部分槽以及槽所映射的键值数据，如图所示：</p> <p><img src="/test/assets/img/image-20200303223144575.a5dcb3ef.png" alt="image-20200303223144575"></p> <p>优点：</p> <ol><li>解耦数据和节点的关系，<strong>简化扩容和收缩难度</strong>。</li> <li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据。</li> <li>支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。</li></ol></li></ul> <h2 id="redis-集群结构"><a href="#redis-集群结构" class="header-anchor">#</a> Redis 集群结构</h2> <ul><li>单节点单机器</li> <li>主从节点</li> <li>哨兵模式</li> <li>集群模式</li></ul> <p>Redis 集群最多可以有 16384 个节点。</p> <h3 id="主从复制"><a href="#主从复制" class="header-anchor">#</a> 主从复制</h3> <p>Redis 中的主从复制，也就是 Master-Slave 模型，多个 Redis 实例间的数据同步以及 Redis 集群中数据同步会使⽤主从复制。</p> <p>主从复制主要是数据同步， 数据同步分为全量同步和增量同步。</p> <ul><li><p>全量同步</p> <p>一般发生在 Slave 初始化阶段，Slave 需要将 Master 所有数据都进行同步复制。</p></li> <li><p>增量同步</p> <p>Slave 正常工作时，Master 节点进行的写操作都会同步到 Slave 节点上。</p></li></ul> <p>优点：可靠性提高了，实现读写分离可以提高读写效率。</p> <p>缺点：主节点存在单点问题，而且需要手动设置故障转移。</p> <h3 id="哨兵模式"><a href="#哨兵模式" class="header-anchor">#</a> 哨兵模式</h3> <p>哨兵模式主要可以解决故障自动转移，不用人为干预。部署哨兵模式必须要有三个节点才能最大化其价值。</p> <p>三个定时任务：</p> <ul><li><p>每 10 秒每个 sentinel 对 master 和 slave 执行 info</p> <p>主要用来发现 slave 节点和确认主从关系。</p></li> <li><p>每 2 秒每个 sentinel 通过 master 结点的 channel 交换信息(pub/sub)</p> <p>可以交互对节点的看法和自身信息。</p></li> <li><p>每 1 秒每个 sentinel 对其他 sentinel 和 redis 执行 ping</p> <p>用来检测故障。</p></li></ul> <p>优点：保证高可用，各个节点自动故障转移。</p> <p>缺点：主从模式，依旧存在单点问题。</p> <h3 id="redis-cluster"><a href="#redis-cluster" class="header-anchor">#</a> Redis Cluster</h3> <p>在上文介绍过，RedisCluster 使用虚拟槽分配节点，即 CRC16(key)&amp;16383（一共有 16384 个），一般结构为三主三从。</p> <p>集群自动故障转移过程分为故障发现和节点恢复。节点下线分为主观下线和客观下线，当超过半数主节点认为故障节点为主观下线时标记它为客观下线状态。从节点负责对客观下线的主节点触发故障恢复流程，保证集群的可用性。</p> <p>优点：</p> <p>避免了单点故障，实现高可用。</p> <p>缺点：</p> <ul><li>使整个缓存更加复杂</li> <li>key 批量操作支持有限：例如 mget、mset 必须在一个 slot。</li> <li>key 事务和 Lua 支持有限：操作的 key 必须在一个节点。</li> <li>key 是数据分区的最小粒度：不支持 bigkey 分区。</li> <li>不支持多个数据库：集群模式下只有一个 db 0。</li> <li>复制只支持一层：不支持树形复制结构。</li></ul> <p>实际上大多数情况下，Redis Sentinel 已经能够胜任，满足业务需求。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/test/基础部分/Mysql.html" class="prev">
        MySQL
      </a></span> <span class="next"><a href="/test/基础部分/源码.html">
        源码
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/test/assets/js/app.fb04842c.js" defer></script><script src="/test/assets/js/2.275389a7.js" defer></script><script src="/test/assets/js/7.dc65d060.js" defer></script>
  </body>
</html>
