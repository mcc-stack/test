<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JVM | 533实验室Java后端知识点整理</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="533实验室Java后端知识点整理">
    <link rel="preload" href="/test/assets/css/0.styles.363e3238.css" as="style"><link rel="preload" href="/test/assets/js/app.fb04842c.js" as="script"><link rel="preload" href="/test/assets/js/2.275389a7.js" as="script"><link rel="preload" href="/test/assets/js/11.3cb03267.js" as="script"><link rel="prefetch" href="/test/assets/js/10.d306dbdb.js"><link rel="prefetch" href="/test/assets/js/12.913d7c94.js"><link rel="prefetch" href="/test/assets/js/13.888020c4.js"><link rel="prefetch" href="/test/assets/js/14.aa2ced95.js"><link rel="prefetch" href="/test/assets/js/15.17131c71.js"><link rel="prefetch" href="/test/assets/js/16.09c5f2c9.js"><link rel="prefetch" href="/test/assets/js/17.b5fb47e1.js"><link rel="prefetch" href="/test/assets/js/18.a85f24aa.js"><link rel="prefetch" href="/test/assets/js/19.e62c702b.js"><link rel="prefetch" href="/test/assets/js/20.de5fd22c.js"><link rel="prefetch" href="/test/assets/js/21.43f72dd9.js"><link rel="prefetch" href="/test/assets/js/22.ea2b70ef.js"><link rel="prefetch" href="/test/assets/js/23.0dbebaf7.js"><link rel="prefetch" href="/test/assets/js/24.37c84f01.js"><link rel="prefetch" href="/test/assets/js/25.1104c8a2.js"><link rel="prefetch" href="/test/assets/js/3.44c5d363.js"><link rel="prefetch" href="/test/assets/js/4.a42ed78f.js"><link rel="prefetch" href="/test/assets/js/5.5558f3f5.js"><link rel="prefetch" href="/test/assets/js/6.af04c27c.js"><link rel="prefetch" href="/test/assets/js/7.dc65d060.js"><link rel="prefetch" href="/test/assets/js/8.25a2093a.js"><link rel="prefetch" href="/test/assets/js/9.2e34f20e.js">
    <link rel="stylesheet" href="/test/assets/css/0.styles.363e3238.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/test/" class="home-link router-link-active"><!----> <span class="site-name">533实验室Java后端知识点整理</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/test/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/lamarsan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/test/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/lamarsan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>基础部分</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/基础部分/操作系统.html" class="sidebar-link">操作系统</a></li><li><a href="/test/基础部分/Linux.html" class="sidebar-link">Linux</a></li><li><a href="/test/基础部分/计算机网络.html" class="sidebar-link">计算机网络</a></li><li><a href="/test/基础部分/JavaSE.html" class="sidebar-link">Java SE</a></li><li><a href="/test/基础部分/JVM.html" class="active sidebar-link">JVM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#运行时数据区" class="sidebar-link">运行时数据区</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#方法区存储内容" class="sidebar-link">方法区存储内容</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#永久代和元空间" class="sidebar-link">永久代和元空间</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#gc-root-的对象" class="sidebar-link">GC Root 的对象</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#常见的-oom" class="sidebar-link">常见的 OOM</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#引用" class="sidebar-link">引用</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#堆内存分配策略" class="sidebar-link">堆内存分配策略</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#full-gc-触发条件" class="sidebar-link">FULL GC 触发条件</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#判断对象是否存活" class="sidebar-link">判断对象是否存活</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#三色标记算法" class="sidebar-link">三色标记算法</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#垃圾回收算法" class="sidebar-link">垃圾回收算法</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#垃圾回收器" class="sidebar-link">垃圾回收器</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#创建对象的步骤" class="sidebar-link">创建对象的步骤</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#类加载过程" class="sidebar-link">类加载过程</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#双亲委派机制" class="sidebar-link">双亲委派机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#工作过程" class="sidebar-link">工作过程</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#使用双亲委派的好处" class="sidebar-link">使用双亲委派的好处</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#破坏双亲委派机制的场景" class="sidebar-link">破坏双亲委派机制的场景</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#打破的方法" class="sidebar-link">打破的方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#tomcat-的类加载器" class="sidebar-link">Tomcat 的类加载器</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#jvm-性能调优" class="sidebar-link">JVM 性能调优</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#常用命令" class="sidebar-link">常用命令</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#常用工具" class="sidebar-link">常用工具</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JVM.html#常用参数" class="sidebar-link">常用参数</a></li></ul></li></ul></li><li><a href="/test/基础部分/多线程并发.html" class="sidebar-link">多线程并发</a></li><li><a href="/test/基础部分/Mysql.html" class="sidebar-link">MySQL</a></li><li><a href="/test/基础部分/Redis.html" class="sidebar-link">Redis</a></li><li><a href="/test/基础部分/源码.html" class="sidebar-link">源码</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架部分</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>大数据</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>项目</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="jvm"><a href="#jvm" class="header-anchor">#</a> JVM</h1> <h2 id="运行时数据区"><a href="#运行时数据区" class="header-anchor">#</a> 运行时数据区</h2> <ol><li>程序计数器</li> <li>虚拟机栈</li> <li>本地方发栈</li> <li>堆</li> <li>方法区</li></ol> <h3 id="方法区存储内容"><a href="#方法区存储内容" class="header-anchor">#</a> 方法区存储内容</h3> <p>类的所有字段和方法字节码，以及一些特殊方法如构造方法，接口代码也在此定义。也就是静态变量+常量+类信息（构造方法/接口定义）+运行时常量池都存在该方法区中。</p> <h3 id="永久代和元空间"><a href="#永久代和元空间" class="header-anchor">#</a> 永久代和元空间</h3> <ul><li>永久代：永久代在 jdk1.7 之后就被元空间给取代了，永久代逻辑结构上属于堆，但是物理上不属于堆，会出现 OOM 异常。</li> <li>元空间：元数据区取代了永久代，本质和永久代类似逻辑结构上属于堆，区别在于元数据区并不在虚拟机中，而是使用本地物理内存，永久代在虚拟机中，元数据区也有可能发生 OutOfMemory 异常。</li></ul> <p>这样就可以不用在单独为方法区去做一个内存管理了。</p> <h2 id="gc-root-的对象"><a href="#gc-root-的对象" class="header-anchor">#</a> GC Root 的对象</h2> <ol><li>虚拟机栈中引用的对象</li> <li>方法区中静态属性引用的对象</li> <li>方法区常量引用的对象</li> <li>本地方法栈中引用的对象</li></ol> <h2 id="常见的-oom"><a href="#常见的-oom" class="header-anchor">#</a> 常见的 OOM</h2> <ul><li>堆内存溢出，堆上对象分配空间不足，有 OutOfMemoryError。</li> <li>栈内存溢出，有 StackOverflow 和 OutOfMemoryError 两类。</li> <li>常量内存溢出</li> <li>直接内存溢出</li></ul> <h2 id="引用"><a href="#引用" class="header-anchor">#</a> 引用</h2> <p>在 java 中主要有以下四种引用类型:强引用,软引用,弱引用,虚引用.不同的引用类型主要体现在 GC 上:</p> <ul><li><p>强引用</p> <p>如果一个对象具有强引用,它就不会被垃圾回收器回收.即使当前内存空间不足,JVM 也不会回收它.而是抛出 OutOfMemoryError 错误.使程序异常终止.如果想中断强引用和某个对象之间的关联.可以显式地将引用赋值为 null,这样一来的话.JVM 在合适的时间就会回收该对象。</p></li> <li><p>软引用</p> <p>在使用软引用时，如果内存的空间足够，软引用就能继续被使用而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。</p></li> <li><p>弱引用</p> <p>具有弱引用的对象拥有的生命周期更短暂，因为当 JVM 进行垃圾回收时，如果这个对象只被弱引用关联（没有任何强引用关联他），那么这个对象就会被回收，不过由于垃圾回收器是一个优先级较低的线程,所以并不一定能迅速发现弱引用对象。弱引用的作用是回收不再使用的键值对，不用弱引用只要桶活着，就不会被回收。</p></li> <li><p>虚引用</p> <p>如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。唯一的作用是能在这个对象被收集器回收时收到一个系统通知，以此判断垃圾回收器的频率。</p></li></ul> <p>之所以出现不同的引用是 Java 对垃圾回收不可控的妥协。</p> <h2 id="堆内存分配策略"><a href="#堆内存分配策略" class="header-anchor">#</a> 堆内存分配策略</h2> <ul><li>对象优先分配在 Eden 区，如果 Eden 区没有足够的空间进行分配时，虚拟机执行一次 MinorGC。</li> <li>大对象直接进入老年代（需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</li> <li>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄（Age Count）计数器，如果对象经过了 1 次 Minor GC 那么对象会进入 Survivor 区，之后每经过一次 Minor GC 那么对象的年龄加 1，直到达到阀值（默认 15 次），对象进入老年区。</li> <li>动态判断对象的年龄。如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</li> <li>空间分配担保。在 Minor GC 前，虚拟机会检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果成立就执行 Minor GC；否则检查 HandlePromotionFailure 设置值是否允许担保失败，如果不允许，直接执行 Full GC；否则检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于的话尝试 Minor GC；否则改为 Full GC。</li></ul> <h2 id="full-gc-触发条件"><a href="#full-gc-触发条件" class="header-anchor">#</a> FULL GC 触发条件</h2> <ol><li>新生代空间不足</li> <li>永久代空间满了</li> <li>CMS GC 时出现 promotion failed 和 concurrent mode failure</li> <li>老年代最大可用的连续空间小于历次晋升到老年代对象的平均大小</li></ol> <h2 id="判断对象是否存活"><a href="#判断对象是否存活" class="header-anchor">#</a> 判断对象是否存活</h2> <p>会有两次检查。第一次扫描并标记不可达对象，并在其中进行筛选没有事先 finalize()或已经调用过 finalize()的对象，让其死亡。第二次检查，会判断该对象是否有必要执行 finalize()方法，稍后会由优先级较低的 Finalizer 线程执行，如果在执行前被重新引用，可以避免死亡。</p> <h2 id="三色标记算法"><a href="#三色标记算法" class="header-anchor">#</a> 三色标记算法</h2> <p>它是描述追踪式回收器的一种有效的方法，利用它可以推演回收器的正确性。</p> <p>我们将对象分成三种类型：</p> <ol><li>黑色：根对象，或者该对象与它的子对象都被扫描过（对象被标记了，且它的所有 field 也被标记完了）。</li> <li>灰色：对象本身被扫描，但还没扫描完该对象中的子对象（它的 field 还没有被标记或标记完）。</li> <li>白色：未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，既垃圾对象（对象没有被标记到）。</li></ol> <h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="header-anchor">#</a> 垃圾回收算法</h2> <ul><li><p>标记清除算法</p> <p>缺点：标记和清除的两个动作效率都不高；清楚后会产生大量不连续的空间碎片。</p></li> <li><p>复制算法</p> <p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，一块用完了，就将存活着的对象复制到另外一块上面。</p> <p>优点：没有碎片问题。</p> <p>缺点：成本太高，内存小了一半。</p></li> <li><p>标记整理算法</p> <p>根据老年代的特点，提出了此算法。标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，最后直接清理掉端边界以外的内存。</p></li> <li><p>分代收集算法</p> <p>新生代使用复制算法；老年代使用标记清除/标记整理算法。</p></li></ul> <h2 id="垃圾回收器"><a href="#垃圾回收器" class="header-anchor">#</a> 垃圾回收器</h2> <ul><li><p>Serial 收集器</p> <p>新生代收集器，它是最基本、发展历史最悠久的收集器。是一个单线程收集器，在垃圾收集时，必须暂停其他所有的工作线程，直到收集结束。适合运行在 Client 模式下的虚拟机。</p></li> <li><p>Serial Old 收集器</p> <p>Serial 收集器的老年代版本，同样也是单线程收集器，使用“标记-整理”算法。</p></li> <li><p>ParNew 收集器</p> <p>新生代收集器，是 Serial 收集器的多线程版本，除了 Serial 收集器外，只有它能与 CMS 收集器配合工作。</p></li> <li><p>Parallel Scavenge 收集器</p> <p>新生代收集器，也是使用复制算法的收集器，又是并行的多线程收集器。它更关注于达到一个可控制的吞吐量。其中，吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。</p> <p>除此之外，它还有自适应调节的特性，虚拟机根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这被称为 GC 自适应的调节策略。它是与 ParNew 收集器的一个重要区别。</p></li> <li><p>Parallel Old 收集器</p> <p>是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。</p></li> <li><p>CMS 收集器</p> <p>老年代收集器，CMS 收集器是一种以获取最短回收停顿时间为目标的收集器，使用“标记-清除”算法。回收过程如下：</p> <ul><li>初始标记：需要 Stop The World，标记能直接关联到的对象。</li> <li>并发标记：可以与用户一起工作，进行 GC Roots Tracing 的过程。</li> <li>重新标记：需要 Stop The World，为了修正并发标记期间因用户程序继续运作而导致标记产生的那一部分对象的标记记录，停顿时间比初始标记稍长一些，远短于并发标记时间。</li> <li>并发清除：可以与用户一起工作。</li></ul> <p>优点：并发收集，低停顿。</p> <p>缺点：吞吐量问题，CMS 对 CPU 资源敏感，会因为占用一部分线程，导致应用程序变慢，使吞吐量降低；浮动垃圾问题，并发清除阶段产生的垃圾叫做浮动垃圾；碎片问题。</p></li> <li><p>G1 收集器</p> <p>在 1.7 时被认为达到足够的商用程度，是收集器技术发展的最前沿成果之一。它是一款面向服务端应用的垃圾收集器。</p> <p>特点：</p> <ul><li><p>并行与并发</p> <p>可以使用多个 CPU 来缩短 Stop-The-World 时间。</p></li> <li><p>分代收集</p> <p>可以管理整个 GC 堆（G1 将内存划分为多个大小相等的区域，并维护一个优先列表，优先回收回收价值最大的 Region），对不同年龄对象采用不同策略。</p></li> <li><p>空间整合</p> <p>整体上采用“标记整理”，局部采用“复制”算法实现，所以不会产生碎片。</p></li> <li><p>可预测的停顿</p></li></ul> <p>收集过程：</p> <ul><li>初始标记：需要停顿，标记 GC Roots 能直接关联到的对象。</li> <li>并发标记：做可达性分析，找出存活的对象。</li> <li>最终标记：需要停顿，但可以并行执行，为了修正在并发标记期间内用户程序继续运作而导致标记产生变动的那一部分标记记录。</li> <li>筛选回收：需要停顿，对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。</li></ul></li></ul> <h2 id="创建对象的步骤"><a href="#创建对象的步骤" class="header-anchor">#</a> 创建对象的步骤</h2> <ul><li><p>检查</p> <p>检查指令的参数是否能在常量池中定位到一个类的符号引用；检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有就执行类加载。</p></li> <li><p>分配内存</p> <p>在类加载后，对象所需的内存已经可以确定了。</p> <ul><li><p>指针碰撞</p> <p>指的是在堆中，空闲区和非空闲区界限分明，中间放着一个指针作为分界点的指示器，所分配的过程就只是将指针向空闲空间的那边挪动一段与对象大小相等的距离。适用于 Serial、ParNew 等带 Compact 过程的收集器。</p></li> <li><p>空闲列表</p> <p>指的是已使用内存和空闲区内存交错的情况下，没办法指针碰撞，而需要维护一个列表，记录内存的可用和不可用，分配时进行更新，适用于基于 Mark-Sweep 算法的 CMS 收集器。</p></li></ul> <p>对分配内存空间动作进行同步处理——虚拟机采用了 CAS 配上失败重试的方式保证更新的原子性。</p></li> <li><p>初始化</p> <p>将分配到的<strong>内存空间</strong>都初始化为零值（不包括对象头），可提前至 TLAB（本地分配缓存区）分配前初始化。初始化保证了不赋初值就可直接使用，程序能访问到这些字段的数据类型所对应的零值。</p></li> <li><p>设置</p> <p>对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。</p></li> <li><p>执行 init</p> <p>以上步骤来说，虚拟机已经产生了一个对象，但从 Java 程序视角来看，对象创建才刚开始，因为还没有执行 init，这一步将对象按照程序员的意愿进行初始化。</p></li></ul> <h2 id="类加载过程"><a href="#类加载过程" class="header-anchor">#</a> 类加载过程</h2> <ul><li><p>加载</p> <p>通过一个类的全限定名获取定义此类的二进制字节流，将这个字节流所代表的的静态存储结构转化为元空间的运行时数据结构，同时在内存中生成一个代表这个类的 java.lang.Class 对象，作为元空间这个类的各种数据的访问入口。</p></li> <li><p>验证</p> <p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并不危害虚拟机自身的安全。</p> <ul><li>文件格式验证</li> <li>元数据验证</li> <li>字节码验证</li> <li>符号引用验证</li></ul></li> <li><p>准备</p> <p>为类变量分配内存并设置初始值，内存都将在元空间中进行分配（被 static 修饰的变量，不包括实例变量），且分配的初始值是各个对象的类初始值。（final 修饰的 static 变量除外，其在此分配对应的值）</p></li> <li><p>解析</p> <p>将常量池内的符号引用替换为直接引用的过程。</p> <ul><li>类或接口的解析</li> <li>字段解析</li> <li>类方法解析</li> <li>接口方法解析</li></ul> <blockquote><p>符号引用：</p> <p>符号引用以一组符号来描述所引用的目标，可以是任何形式的字面量。</p> <p>直接引用：</p> <p>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</p></blockquote></li> <li><p>初始化</p> <p>类加载过程的最后一步，真正开始执行类中定义的 Java 字节码。（执行&lt;clinit&gt;()方法的过程，为静态变量赋值）</p></li></ul> <h2 id="双亲委派机制"><a href="#双亲委派机制" class="header-anchor">#</a> 双亲委派机制</h2> <p><img src="/test/assets/img/image-20200302170404221.ffad1c71.png" alt="image-20200302170404221"></p> <h3 id="工作过程"><a href="#工作过程" class="header-anchor">#</a> 工作过程</h3> <ol><li>收到类请求；</li> <li>请求委派给父类；</li> <li>到启动类时，如果找不到所需的类，就传递给子加载器。</li></ol> <h3 id="使用双亲委派的好处"><a href="#使用双亲委派的好处" class="header-anchor">#</a> 使用双亲委派的好处</h3> <ol><li>保证稳定性，类随着类加载器具有统一优先级的层次关系；</li> <li>虚拟机只有在两个类的类名相同且加载该类的加载器均相同的情况下才判定这是一个类。若不采用双亲委派机制，同一个类有可能被多个类加载器加载，这样该类会被识别为两个不同的类，相互赋值时会有问题。</li></ol> <h3 id="破坏双亲委派机制的场景"><a href="#破坏双亲委派机制的场景" class="header-anchor">#</a> 破坏双亲委派机制的场景</h3> <ul><li><p>基础类要调用用户的代码</p> <p>一个典型的例子就是 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器去加载，但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的 ClassPath 下的 JNDI 接口提供者的代码，但启动类加载器不可能“认识”这些代码。</p> <p>为了解决这个问题，Java 团队引入了线程上下文类加载器(Thread Context ClassLoader)。有了线程上下文加载器，JNDI 服务就可以使用它去加载所需要的 SPI 代码，也就是<strong>父类加载器请求子类加载器</strong>去完成类加载的动作，这种行为实际上就是打通了双亲委派模型层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。</p></li> <li><p>用户对程序动态性的追求</p> <p>所谓的动态性是指代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。</p> <p>OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。</p></li></ul> <h3 id="打破的方法"><a href="#打破的方法" class="header-anchor">#</a> 打破的方法</h3> <p>重写 ClassLoader 类中的 <strong>loadClass()</strong> 方法即可打破，重写 findClass()是不会打破的，它的作用是加载无法被父类加载器加载的类。</p> <h2 id="tomcat-的类加载器"><a href="#tomcat-的类加载器" class="header-anchor">#</a> Tomcat 的类加载器</h2> <p><img src="/test/assets/img/image-20200302170828189.18d41f45.png" alt="image-20200302170828189"></p> <ul><li>CommonLoader：Tomcat 最基本的类加载器，加载路径中的 class 可以被 Tomcat 容器本身以及各个 Webapp 访问；</li> <li>CatalinaLoader：Tomcat 容器私有的类加载器，加载路径中的 class 对于 Webapp 不可见；</li> <li>SharedLoader：各个 Webapp 共享的类加载器，加载路径中的 class 对于所有 Webapp 可见，但是对于 Tomcat 容器不可见；</li> <li>WebappClassLoader：各个 Webapp 私有的类加载器，加载路径中的 class 只对当前 Webapp 可见。</li></ul> <blockquote><ul><li><p>CommonClassLoader 能加载的类都可以被 Catalina ClassLoader 和 SharedClassLoader 使用，从而实现了公有类库的共用，而 CatalinaClassLoader 和 Shared ClassLoader 自己能加载的类则与对方相互隔离。</p></li> <li><p>WebAppClassLoader 可以使用 SharedClassLoader 加载到的类，但各个 WebAppClassLoader 实例之间相互隔离。</p></li> <li><p>JasperLoader 的加载范围仅仅是这个 JSP 文件所编译出来的那一个.Class 文件，它出现的目的就是为了被丢弃：当 Web 容器检测到 JSP 文件被修改时，会替换掉目前的 JasperLoader 的实例，并通过再建立一个新的 Jsp 类加载器来实现 JSP 文件的 HotSwap 功能。</p></li></ul></blockquote> <p>双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当由自己的父类加载器加载。很显然 Tomcat 已经<strong>打破了双亲委派模型</strong>，为了实现隔离性，每个 webappClassLoader 加载自己的目录下的 class 文件，不会传递给父类加载器。如果 tomcat 的 Common ClassLoade 想加载 WebApp ClassLoader 中的类，可以使用线程上下文加载器实现。</p> <h2 id="jvm-性能调优"><a href="#jvm-性能调优" class="header-anchor">#</a> JVM 性能调优</h2> <h3 id="常用命令"><a href="#常用命令" class="header-anchor">#</a> 常用命令</h3> <ul><li><p>jps</p> <p>显示系统内所有的 HotSpot 虚拟机进程。</p></li> <li><p>jstat</p> <p>虚拟机统计信息监视工具。</p></li> <li><p>jinfo</p> <p>Java 配置信息工具。</p></li> <li><p>jmap</p> <p>Java 内存映像工具。</p></li> <li><p>jhat</p> <p>虚拟机堆转储快照分析工具。</p></li> <li><p>jstack</p> <p>Java 堆栈跟踪工具。</p></li> <li><p>HSDIS</p> <p>JIT 生成代码反汇编。</p></li></ul> <h3 id="常用工具"><a href="#常用工具" class="header-anchor">#</a> 常用工具</h3> <ul><li><p>JConsole</p> <p>Java 监视与管理控制台。</p></li> <li><p>VsualVM</p> <p>多合一故障处理工具。</p></li></ul> <h3 id="常用参数"><a href="#常用参数" class="header-anchor">#</a> 常用参数</h3> <p><strong>参数说明</strong></p> <ul><li><p>标准参数（-），所有的 JVM 实现都必须实现这些参数的功能，而且向后兼容；</p></li> <li><p>非标准参数（-X），默认 jvm 实现这些参数的功能，但是并不保证所有 jvm 实现都满足，且不保证向后兼容；</p></li> <li><p>非 Stable 参数（-XX），此类参数各个 jvm 实现会有所不同，将来可能会随时取消，需要慎重使用。</p></li></ul> <p>在选项名前用 “+” 或 “-” 表示开启或关闭特定的选项，例：</p> <p>-XX:+UseCompressedOops：表示开启 压缩指针</p> <p>-XX:-UseCompressedOops：表示关闭 压缩指针</p> <p><strong>常见参数设置</strong></p> <ul><li>-Xms：初始堆大小</li> <li>-Xmx：最大堆大小</li> <li>-Xmn：新生代大小</li> <li>-Xss：每个线程的虚拟机栈大小</li> <li>-XX:NewSize：新生代初始大小</li> <li>-XX:NewSize：新生代最大值</li> <li>-XX:MetaspaceSize：设置元数据空间初始大小（取代-XX:PermSize）</li> <li>-XX:MaxMetaspaceSize：设置元数据空间最大值（取代之前-XX:MaxPermSize）</li> <li>-XX:+PrintGCDetails：打印 GC 信息</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/test/基础部分/JavaSE.html" class="prev">
        Java SE
      </a></span> <span class="next"><a href="/test/基础部分/多线程并发.html">
        多线程并发
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/test/assets/js/app.fb04842c.js" defer></script><script src="/test/assets/js/2.275389a7.js" defer></script><script src="/test/assets/js/11.3cb03267.js" defer></script>
  </body>
</html>
