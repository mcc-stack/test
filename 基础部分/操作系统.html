<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>操作系统 | 533实验室Java后端知识点整理</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="533实验室Java后端知识点整理">
    <link rel="preload" href="/test/assets/css/0.styles.363e3238.css" as="style"><link rel="preload" href="/test/assets/js/app.fb04842c.js" as="script"><link rel="preload" href="/test/assets/js/2.275389a7.js" as="script"><link rel="preload" href="/test/assets/js/18.a85f24aa.js" as="script"><link rel="prefetch" href="/test/assets/js/10.d306dbdb.js"><link rel="prefetch" href="/test/assets/js/11.3cb03267.js"><link rel="prefetch" href="/test/assets/js/12.913d7c94.js"><link rel="prefetch" href="/test/assets/js/13.888020c4.js"><link rel="prefetch" href="/test/assets/js/14.aa2ced95.js"><link rel="prefetch" href="/test/assets/js/15.17131c71.js"><link rel="prefetch" href="/test/assets/js/16.09c5f2c9.js"><link rel="prefetch" href="/test/assets/js/17.b5fb47e1.js"><link rel="prefetch" href="/test/assets/js/19.e62c702b.js"><link rel="prefetch" href="/test/assets/js/20.de5fd22c.js"><link rel="prefetch" href="/test/assets/js/21.43f72dd9.js"><link rel="prefetch" href="/test/assets/js/22.ea2b70ef.js"><link rel="prefetch" href="/test/assets/js/23.0dbebaf7.js"><link rel="prefetch" href="/test/assets/js/24.37c84f01.js"><link rel="prefetch" href="/test/assets/js/25.1104c8a2.js"><link rel="prefetch" href="/test/assets/js/3.44c5d363.js"><link rel="prefetch" href="/test/assets/js/4.a42ed78f.js"><link rel="prefetch" href="/test/assets/js/5.5558f3f5.js"><link rel="prefetch" href="/test/assets/js/6.af04c27c.js"><link rel="prefetch" href="/test/assets/js/7.dc65d060.js"><link rel="prefetch" href="/test/assets/js/8.25a2093a.js"><link rel="prefetch" href="/test/assets/js/9.2e34f20e.js">
    <link rel="stylesheet" href="/test/assets/css/0.styles.363e3238.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/test/" class="home-link router-link-active"><!----> <span class="site-name">533实验室Java后端知识点整理</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/test/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/lamarsan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/test/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/lamarsan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>基础部分</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/基础部分/操作系统.html" class="active sidebar-link">操作系统</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#进程和线程的区别" class="sidebar-link">进程和线程的区别</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#线程和协程的区别" class="sidebar-link">线程和协程的区别</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#进程间通信的方式" class="sidebar-link">进程间通信的方式</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#线程共享与独占的资源" class="sidebar-link">线程共享与独占的资源</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#共享内容" class="sidebar-link">共享内容</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#独占内容" class="sidebar-link">独占内容</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#作业调度算法" class="sidebar-link">作业调度算法</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#进程分配的内存空间" class="sidebar-link">进程分配的内存空间</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#存储管理" class="sidebar-link">存储管理</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#页面置换算法-内存调度" class="sidebar-link">页面置换算法/内存调度</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#死锁条件与解决方式" class="sidebar-link">死锁条件与解决方式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#死锁概念及产生原理" class="sidebar-link">死锁概念及产生原理</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#必要条件" class="sidebar-link">必要条件</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#死锁预防" class="sidebar-link">死锁预防</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#死锁避免" class="sidebar-link">死锁避免</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#死锁的检测与解除" class="sidebar-link">死锁的检测与解除</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#fork-系统调用" class="sidebar-link">fork()系统调用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#exec" class="sidebar-link">exec()</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#copy-on-write" class="sidebar-link">Copy-On-Write</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#联系-fork" class="sidebar-link">联系 fork()</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#优点" class="sidebar-link">优点</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#缺点" class="sidebar-link">缺点</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#僵尸进程和孤儿进程" class="sidebar-link">僵尸进程和孤儿进程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#僵尸进程" class="sidebar-link">僵尸进程</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#孤儿进程" class="sidebar-link">孤儿进程</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#系统调用、异常和中断" class="sidebar-link">系统调用、异常和中断</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/操作系统.html#用户态和内核态" class="sidebar-link">用户态和内核态</a></li></ul></li><li><a href="/test/基础部分/Linux.html" class="sidebar-link">Linux</a></li><li><a href="/test/基础部分/计算机网络.html" class="sidebar-link">计算机网络</a></li><li><a href="/test/基础部分/JavaSE.html" class="sidebar-link">Java SE</a></li><li><a href="/test/基础部分/JVM.html" class="sidebar-link">JVM</a></li><li><a href="/test/基础部分/多线程并发.html" class="sidebar-link">多线程并发</a></li><li><a href="/test/基础部分/Mysql.html" class="sidebar-link">MySQL</a></li><li><a href="/test/基础部分/Redis.html" class="sidebar-link">Redis</a></li><li><a href="/test/基础部分/源码.html" class="sidebar-link">源码</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架部分</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>大数据</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>项目</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="操作系统"><a href="#操作系统" class="header-anchor">#</a> 操作系统</h1> <h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="header-anchor">#</a> 进程和线程的区别</h2> <ol><li>进程是资源的分配和调度的一个独立单元，而线程是 CPU 调度的基本单元。</li> <li>同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包括一个线程。</li> <li>进程的创建调用 fork 或者 vfork，而线程的创建调用 pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束。</li> <li>线程是轻量级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的。</li> <li>线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源。</li> <li>线程有自己的私有属性 TCB，线程 id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块 PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志。</li></ol> <h2 id="线程和协程的区别"><a href="#线程和协程的区别" class="header-anchor">#</a> 线程和协程的区别</h2> <p><strong>协程是一种用户态的轻量级线程，</strong> 协程的调度完全由用户控制。</p> <ol><li>一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样 python 中则能使用多核 CPU。</li> <li>线程进程都是同步机制，而协程则是异步。</li> <li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。</li></ol> <h2 id="进程间通信的方式"><a href="#进程间通信的方式" class="header-anchor">#</a> 进程间通信的方式</h2> <ul><li><p>管道</p> <p>速度慢，容量有限，只有父子进程能通讯。</p></li> <li><p>FIFO</p> <p>FIFO，也称为命名管道，它是一种文件类型。任何进程间都能通讯，但速度慢。</p> <p>特点：</p> <p>1）FIFO 可以在无关的进程之间交换数据，与无名管道不同。</p> <p>2）FIFO 有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。</p></li> <li><p>消息队列</p> <p>容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。</p></li> <li><p>信号量</p> <p>不能传递复杂消息，只能用来同步。</p></li> <li><p>Socket</p> <p>使用网络进行交互。</p></li> <li><p>共享内存区</p> <p>共享内存是分配一块能被其他进程访问的内存，实现是通过将内存映射到共享它的进程的地址空间，使这些进程间的数据传送不再涉及内核，即进程间通信不需要通过进入内核的系统调用实现。共享内存几乎没有上限，它也不局限于父子进程，因为内存是共享的，不存在单向的限制；最大的问题就是需要应用程序自己实现互斥。</p> <p>最大优点：数据赋值只需 2 次，一次是从输入文件到共享内存区，一次是从共享内存区到输出文件。其他的通信方式需要四次：服务器将输入文件读入自己的进程空间，再从自己的进程空间写入管道/消息队列等；客户进程从管道/消息队列读出数据到自己的进程空间，最后输出到用户指定的文件中。因此共享内存是<strong>最快</strong>的进程间通信方式，因为它不涉及内存的交互，所以效率很高。</p></li></ul> <h2 id="线程共享与独占的资源"><a href="#线程共享与独占的资源" class="header-anchor">#</a> 线程共享与独占的资源</h2> <h3 id="共享内容"><a href="#共享内容" class="header-anchor">#</a> 共享内容</h3> <p>代码段、数据段、堆空间、进程打开的文件描述符、进程的当前目录以及进程的用户 ID 和组 ID。</p> <h3 id="独占内容"><a href="#独占内容" class="header-anchor">#</a> 独占内容</h3> <p>栈、线程 ID、寄存器的值、错误返回码以及线程的信号屏蔽码。</p> <h2 id="作业调度算法"><a href="#作业调度算法" class="header-anchor">#</a> 作业调度算法</h2> <ul><li><p>先来先服务调度算法</p> <p>按作业到达的先后次序进行调度。</p></li> <li><p>短作业优先调度算法</p> <p>优先调度运行时间最短的作业。</p></li> <li><p>响应比高者优先调度算法</p> <p>响应比 R=1+W/T，W 为作业在后备状态队列中的等待时间，T 为该作业估计需要的执行时间。</p></li> <li><p>轮转法</p> <p>将 CPU 的处理时间分成固定大小的时间片，时间片长度 q 的选择是根据系统对相应时间的要求 R 和就绪队列中所允许的最大进程数 Nmax 确定的：q=R/Nmax。</p></li> <li><p>优先级法</p> <p>根据事先设置好的优先级进行调度。</p></li></ul> <h2 id="进程分配的内存空间"><a href="#进程分配的内存空间" class="header-anchor">#</a> 进程分配的内存空间</h2> <ul><li>栈区：由编译器自动分配和释放，存放函数的参数值，局部变量的值等。</li> <li>堆区：一般有程序员分配和释放，若程序员不释放，程序结束后可能有 OS 回收。线程共享。</li> <li>全局区（静态区 static）：全局变量和静态变量存储在这一区域，初始化的全局变量和静态变量在这一区域，未初始化的全局变量和未初始化的静态变量在相邻的另一区域。程序结束后由系统释放。</li> <li>文字常量区：常量字符串存放在这一区域。程序结束后由系统释放。</li> <li>程序代码区：存放函数体的二进制代码。</li></ul> <h2 id="存储管理"><a href="#存储管理" class="header-anchor">#</a> 存储管理</h2> <p>主要有页式管理、段式管理和段页式管理。</p> <ul><li><p>页式管理</p> <p>基本原理是将各进程的虚拟空间划分为若干个长度相等的页。把内存空间按页的大小划分为片或者页面，然后把页式虚拟地址与内存地址建立一一对应的页表，并用相应的硬件地址转换机构来解决离散地址变换问题。</p> <p><strong>优点：</strong> 没有外碎片，每个内碎片不超过页的大小。</p> <p><strong>缺点：</strong> 程序全部装入内存，要求有相应的硬件支持，如地址变换机构缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。增加了机器成本和系统开销。</p> <blockquote><p>快表</p> <p>CPU 每次要存取一个数据，都要两次访问内存（访问页表、访问实际物理地址）。为提高地址变换速度，增设一个具有并行查询能力的特殊高速缓冲存储器，称为“联想存储器”或“快表”，存放当前访问的页表项。</p></blockquote></li> <li><p>段式管理</p> <p>基本思想是把程序按内容或过程函数关系分成段，每段有自己的名字。一个用户作业或者进程所包含的段对应一个二维线性虚拟空间，也就是一个二维虚拟存储器。段式管理程序以段为单位分配内存，然后通过地址映射机构把段式虚拟地址转换为实际内存物理地址。</p> <p><strong>优点：</strong></p> <p>1）具有逻辑独立性，易于维护，也便于多道程序共享。</p> <p>2）段长可以动态改变，允许自由调度。</p> <p>3）方便编程。</p> <p><strong>缺点：</strong> 会产生碎片。</p></li> <li><p>段页式管理</p> <p>先分段，后分页。系统必须为每个作业或者进程建立一张段表以管理内存分配与释放、缺段处理等。另外由于一个段又被划分为若干个页，每个段必须建立一张页表以把段中的虚页变换为内存中的实际页面。显然与页式管理时相同，页表也要有相应的实现缺页中断处理和页面保护等功能的表项。</p> <p>段页式管理是段式管理和页式管理相结合而成，具有两者的优点。缺点是，由于管理软件的增加，复杂性和开销也增加。另外需要的硬件以及占用的内存也有所增加，使得执行速度下降。</p></li></ul> <h2 id="页面置换算法-内存调度"><a href="#页面置换算法-内存调度" class="header-anchor">#</a> 页面置换算法/内存调度</h2> <ul><li><p>随机淘汰算法</p></li> <li><p>轮转法</p></li> <li><p>最佳置换算法（OPT）</p> <p>这是一种理想情况下的页面置换算法，但实际上是不可能实现的。该算法的基本思想是：发生缺页时，有些页面在内存中，其中有一页将很快被访问（也包含紧接着的下一条指令的那页），而其他页面则可能要到 10、100 或者 1000 条指令后才会被访问，每个页面都可 [1] 以用在该页面首次被访问前所要执行的指令数进行标记。最佳页面置换算法只是简单地规定：标记最大的页应该被置换。</p></li> <li><p>先进先出置换算法（FIFO）</p> <p>最简单的页面置换算法是先入先出（FIFO）法。这种算法的实质是，总是选择在主存中停留时间最长（即最老）的一页置换，即先进入内存的页，先退出内存。理由是：最早调入内存的页，其不再被使用的可能性比刚调入内存的可能性大。</p></li> <li><p>最近最久未使用算法（LRU）</p> <p>它的实质是，当需要置换一页时，选择在之前一段时间里最久没有使用过的页面予以置换。这种算法就称为最久未使用算法。java 使用 LinkedList 实现 LRU 算法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * className: LRUCache
 * description: 用双向链表实现LRU
 * 链表尾表示最近被访问的元素，越靠近链表头表示越早之前被访问的元素.
 *
 * @author lamar
 * @version 1.0
 * @date 2020/2/29 22:52
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> cache<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> iterator <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Node</span> node <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>key <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                result <span class="token operator">=</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 添加到链表尾部</span>
                <span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 遍历，如果存在，直接删除</span>
        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> iterator <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Node</span> node <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>key <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 找不到且容量已满，删除链表头部</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">==</span> cache<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            cache<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 添加到链表尾部</span>
        cache<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> key<span class="token punctuation">;</span>
        <span class="token keyword">int</span> val<span class="token punctuation">;</span>

        <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="死锁条件与解决方式"><a href="#死锁条件与解决方式" class="header-anchor">#</a> 死锁条件与解决方式</h2> <h3 id="死锁概念及产生原理"><a href="#死锁概念及产生原理" class="header-anchor">#</a> 死锁概念及产生原理</h3> <p><strong>概念：</strong> 多个并发进程因争夺系统资源而产生相互等待的现象。</p> <p><strong>原理：</strong> 当一组进程中的每个进程都在等待某个事件发生，而只有这组进程中的其他进程才能触发该事件，这就称这组进程发生了死锁。</p> <p><strong>本质原因：</strong></p> <ul><li><p>系统资源有限</p></li> <li><p>进程推进顺序不合理</p></li></ul> <h3 id="必要条件"><a href="#必要条件" class="header-anchor">#</a> 必要条件</h3> <ol><li>互斥条件：一个资源每次只能被一个进程使用。</li> <li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li> <li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</li> <li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol> <h3 id="死锁预防"><a href="#死锁预防" class="header-anchor">#</a> 死锁预防</h3> <ul><li><p>破坏请求与保持条件</p> <p>所有的进程在开始运行之前，必须一次性地申请其在整个运行过程中所需要的全部资源。</p></li> <li><p>破坏不可剥夺条件</p> <p>当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。会很大程度上影响系统吞吐量。</p></li> <li><p>破坏循环等待条件</p> <p>可以通过定义资源类型的线性顺序来预防，可将每个资源编号，当一个进程占有编号为 i 的资源时，那么它下一次申请资源只能申请编号大于 i 的资源。</p></li></ul> <h3 id="死锁避免"><a href="#死锁避免" class="header-anchor">#</a> 死锁避免</h3> <p>死锁避免是利用额外的检验信息，在分配资源时判断是否会出现死锁，只在不会出现死锁的情况下才分配资源。</p> <p>两种避免办法：</p> <ol><li><p>如果一个进程的请求会导致死锁，则不启动该进程。</p></li> <li><p>如果一个进程的增加资源请求会导致死锁，则拒绝该申请。</p></li></ol> <p>避免死锁的具体实现通常利用银行家算法。</p> <h3 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="header-anchor">#</a> 死锁的检测与解除</h3> <p>常用的接触死锁的方法：</p> <ol><li><p>抢占资源：从一个或多个进程中抢占足够数量的资源分配给死锁进程，以解除死锁状态。</p></li> <li><p>终止（或撤销）进程：终止或撤销系统中的一个或多个死锁进程，直至打破死锁状态。</p></li></ol> <h2 id="fork-系统调用"><a href="#fork-系统调用" class="header-anchor">#</a> fork()系统调用</h2> <p>fork()的作用就是创建一个该进程下的子进程，在其 exit 或 exec 之前，和他共享代码。</p> <ul><li><p>fork 系统调用之后，父进程和子进程交替执行，并且它们处于不同空间中。</p></li> <li><p>fork()函数的一次调用返回 2 次返回，此时二个进程处于独立的空间，它们各自执行着自己的东西,不产生冲突，所以返回 2 次。创建成功后，对于父进程来说是返回子进程的 ID，而对于子进程来说就是返回 0。而至于是先子进程还是父进程先执行,这没有确切的规定,是随机的。创建失败返回-1。</p></li> <li><p>fork()的子执行过程在 fork()之后并不是从头开始,因为在 fork()之前,父进程已经为子进程搭建好了运行环境了。</p></li></ul> <h3 id="exec"><a href="#exec" class="header-anchor">#</a> exec()</h3> <p>fork 会创建一个子进程。<strong>子进程的是父进程的副本</strong>。</p> <p>exec 函数的作用就是：<strong>装载一个新的程序</strong>（可执行映像）覆盖<strong>当前进程</strong>内存空间中的映像，<strong>从而执行不同的任务</strong>。</p> <ul><li>exec 系列函数在执行时会<strong>直接替换掉当前进程的地址空间</strong>。</li></ul> <h2 id="copy-on-write"><a href="#copy-on-write" class="header-anchor">#</a> Copy-On-Write</h2> <p>写时复制， 是一种计算机程序设计领域的优化策略，多个调用者可以请求相同的资源，只有修改时，系统会复制一份副本给要修改的调用者，而其他调用者看到的仍是最初的资源。</p> <h3 id="联系-fork"><a href="#联系-fork" class="header-anchor">#</a> 联系 fork()</h3> <p>如果按<strong>传统</strong>的做法，会<strong>直接</strong>将父进程的数据拷贝到子进程中，拷贝完之后，父进程和子进程之间的数据段和堆栈是<strong>相互独立的</strong>。但是子进程往往会执行自己想要实现的功能，从而清空父进程的数据，导致拷贝失效。于是就有了 COW。</p> <ul><li>fork 创建出的子进程，<strong>与父进程共享内存空间</strong>。也就是说，如果子进程<strong>不对内存空间进行写入操作的话，内存空间中的数据并不会复制给子进程</strong>，这样创建子进程的速度就很快了！(不用复制，直接引用父进程的物理空间)。</li> <li>并且如果在 fork 函数返回之后，子进程<strong>第一时间</strong>exec 一个新的可执行映像，那么也不会浪费时间和内存空间了。</li></ul> <h3 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h3> <ul><li>COW 技术可<strong>减少</strong>分配和复制大量资源时带来的<strong>瞬间延时</strong>。</li> <li>COW 技术可减少<strong>不必要的资源分配</strong>。比如 fork 进程时，并不是所有的页面都需要复制，父进程的<strong>代码段和只读数据段都不被允许修改，所以无需复制</strong>。</li></ul> <h3 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h3> <p>如果在 fork()之后，父子进程都还需要继续进行写操作，<strong>那么会产生大量的分页错误(页异常中断 page-fault)</strong>，这样就得不偿失。</p> <h2 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="header-anchor">#</a> 僵尸进程和孤儿进程</h2> <h3 id="僵尸进程"><a href="#僵尸进程" class="header-anchor">#</a> 僵尸进程</h3> <p>创建子进程后，如果子进程比父进程早结束，而且父进程迟迟没有结束，那么子进程就会进入一个 Z 状态——僵尸状态，并且占用系统资源。僵尸状态对操作系统是有害的，kill -9 也无法处理，只能等父进程来处理。</p> <p>解决方法：</p> <ul><li><p>进程等待</p> <p>让父进程等待子进程，子进程工作完父进程再执行工作。</p></li> <li><p>托付给 Init 进程</p> <p>用子进程再创建一个子进程，此时子进程就成了 <strong>子进程的子进程</strong> 的父进程，然后让子进程结束，那么 <strong>子进程的子进程</strong> 接受本应该子进程接受的任务，而且 <strong>子进程的子进程</strong> 此时成了孤儿进程，他的生死父进程也不会过问，交给 1 号进程 init 来解决。</p></li></ul> <h3 id="孤儿进程"><a href="#孤儿进程" class="header-anchor">#</a> 孤儿进程</h3> <p>子进程还在世的时候父进程却结束了，对系统无害。init 进程会收养孤儿进程，孤儿进程结束时第一时间回收他们的退出信息，保证他们不一直成为僵尸进程。</p> <h2 id="系统调用、异常和中断"><a href="#系统调用、异常和中断" class="header-anchor">#</a> 系统调用、异常和中断</h2> <ul><li>系统调用：应用程序主动向操作系统发出的服务请求。</li> <li>异常：非法指令或其他原因导致当前指令执行失败后的处理请求。</li> <li>中断：来自硬件设备的处理请求。</li></ul> <p>无论任何一种都可能发生用户态到内核态之间的转换。</p> <h2 id="用户态和内核态"><a href="#用户态和内核态" class="header-anchor">#</a> 用户态和内核态</h2> <p>内核态与用户态是操作系统的两种运行级别，当程序运行在 3 级特权级上时，就可以称之为运行在用户态。<strong>因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态；</strong>
当程序运行在 0 级特权级上时，就可以称之为运行在内核态。</p> <p><strong>区别：</strong></p> <ul><li>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的。</li> <li>处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。</li></ul> <p>这个状态，连最无情的 kill -9 也无法处理，只能等父进程来处理。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/test/基础部分/Linux.html">
        Linux
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/test/assets/js/app.fb04842c.js" defer></script><script src="/test/assets/js/2.275389a7.js" defer></script><script src="/test/assets/js/18.a85f24aa.js" defer></script>
  </body>
</html>
