<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java SE | 533实验室Java后端知识点整理</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="533实验室Java后端知识点整理">
    <link rel="preload" href="/test/assets/css/0.styles.363e3238.css" as="style"><link rel="preload" href="/test/assets/js/app.fb04842c.js" as="script"><link rel="preload" href="/test/assets/js/2.275389a7.js" as="script"><link rel="preload" href="/test/assets/js/4.a42ed78f.js" as="script"><link rel="prefetch" href="/test/assets/js/10.d306dbdb.js"><link rel="prefetch" href="/test/assets/js/11.3cb03267.js"><link rel="prefetch" href="/test/assets/js/12.913d7c94.js"><link rel="prefetch" href="/test/assets/js/13.888020c4.js"><link rel="prefetch" href="/test/assets/js/14.aa2ced95.js"><link rel="prefetch" href="/test/assets/js/15.17131c71.js"><link rel="prefetch" href="/test/assets/js/16.09c5f2c9.js"><link rel="prefetch" href="/test/assets/js/17.b5fb47e1.js"><link rel="prefetch" href="/test/assets/js/18.a85f24aa.js"><link rel="prefetch" href="/test/assets/js/19.e62c702b.js"><link rel="prefetch" href="/test/assets/js/20.de5fd22c.js"><link rel="prefetch" href="/test/assets/js/21.43f72dd9.js"><link rel="prefetch" href="/test/assets/js/22.ea2b70ef.js"><link rel="prefetch" href="/test/assets/js/23.0dbebaf7.js"><link rel="prefetch" href="/test/assets/js/24.37c84f01.js"><link rel="prefetch" href="/test/assets/js/25.1104c8a2.js"><link rel="prefetch" href="/test/assets/js/3.44c5d363.js"><link rel="prefetch" href="/test/assets/js/5.5558f3f5.js"><link rel="prefetch" href="/test/assets/js/6.af04c27c.js"><link rel="prefetch" href="/test/assets/js/7.dc65d060.js"><link rel="prefetch" href="/test/assets/js/8.25a2093a.js"><link rel="prefetch" href="/test/assets/js/9.2e34f20e.js">
    <link rel="stylesheet" href="/test/assets/css/0.styles.363e3238.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/test/" class="home-link router-link-active"><!----> <span class="site-name">533实验室Java后端知识点整理</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/test/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/lamarsan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/test/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/lamarsan" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>基础部分</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/基础部分/操作系统.html" class="sidebar-link">操作系统</a></li><li><a href="/test/基础部分/Linux.html" class="sidebar-link">Linux</a></li><li><a href="/test/基础部分/计算机网络.html" class="sidebar-link">计算机网络</a></li><li><a href="/test/基础部分/JavaSE.html" class="active sidebar-link">Java SE</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#面向对象基本特性介绍" class="sidebar-link">面向对象基本特性介绍</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#多态实现原理" class="sidebar-link">多态实现原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#方法表" class="sidebar-link">方法表</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#java-基本类型" class="sidebar-link">Java 基本类型</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#jdk、jre-和-jvm" class="sidebar-link">JDK、JRE 和 JVM</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#常用包" class="sidebar-link">常用包</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#重载与重写" class="sidebar-link">重载与重写</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#内存泄漏的场景" class="sidebar-link">内存泄漏的场景</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#引用类型" class="sidebar-link">引用类型</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#场景" class="sidebar-link">场景</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#序列化与反序列化" class="sidebar-link">序列化与反序列化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#实现序列化的好处" class="sidebar-link">实现序列化的好处</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#实现原理" class="sidebar-link">实现原理</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#序列化-反序列化失败场景" class="sidebar-link">序列化/反序列化失败场景</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#访问权限" class="sidebar-link">访问权限</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#与-的区别" class="sidebar-link">&amp;与&amp;&amp;的区别</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#array-和-arraylist-的区别" class="sidebar-link">Array 和 ArrayList 的区别</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#comparable-和-comparator-接口的作用以及区别" class="sidebar-link">Comparable 和 Comparator 接口的作用以及区别</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#collection-和-collections-的区别" class="sidebar-link">Collection 和 Collections 的区别</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#快速失败-fail-fast-和安全失败-fail-safe-的区别" class="sidebar-link">快速失败(fail-fast)和安全失败(fail-safe)的区别</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#值传递和引用传递" class="sidebar-link">值传递和引用传递</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#double-类型的比较" class="sidebar-link">Double 类型的比较</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#equals-与-hashcode" class="sidebar-link">equals 与 hashCode</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#arraylist-与-linkedlist-的区别" class="sidebar-link">ArrayList 与 LinkedList 的区别</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#异常体系" class="sidebar-link">异常体系</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#反射" class="sidebar-link">反射</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#工作原理" class="sidebar-link">工作原理</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#工作流程" class="sidebar-link">工作流程</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#内部类" class="sidebar-link">内部类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#为什么需要-final" class="sidebar-link">为什么需要 final</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#抽象类和接口的区别" class="sidebar-link">抽象类和接口的区别</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#泛型" class="sidebar-link">泛型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#使用泛型的好处" class="sidebar-link">使用泛型的好处</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#类型擦除" class="sidebar-link">类型擦除</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#限定通配符与非限定通配符" class="sidebar-link">限定通配符与非限定通配符</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#list-和-list-object-的区别" class="sidebar-link">List的区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#注解" class="sidebar-link">注解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#元注解" class="sidebar-link">元注解</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#注解的属性" class="sidebar-link">注解的属性</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#java-预置的注解" class="sidebar-link">Java 预置的注解</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#如何使用" class="sidebar-link">如何使用</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#io" class="sidebar-link">IO</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#分类" class="sidebar-link">分类</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#字节流和字符流的区别" class="sidebar-link">字节流和字符流的区别</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#randomaccessfile" class="sidebar-link">RandomAccessFile</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#system-out-println" class="sidebar-link">System.out.println</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#缓冲区" class="sidebar-link">缓冲区</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#printstream、bufferedwriter、printwriter" class="sidebar-link">PrintStream、BufferedWriter、PrintWriter</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#节点流与处理流" class="sidebar-link">节点流与处理流</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#流的关闭操作" class="sidebar-link">流的关闭操作</a></li></ul></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#java8-新特性" class="sidebar-link">Java8 新特性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#lambda-表达式" class="sidebar-link">Lambda 表达式</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#接口的默认方法" class="sidebar-link">接口的默认方法</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#localdatetime" class="sidebar-link">LocalDateTime</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#optional-类" class="sidebar-link">Optional 类</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#stream-api" class="sidebar-link">Stream API</a></li><li class="sidebar-sub-header"><a href="/test/基础部分/JavaSE.html#其他" class="sidebar-link">其他</a></li></ul></li></ul></li><li><a href="/test/基础部分/JVM.html" class="sidebar-link">JVM</a></li><li><a href="/test/基础部分/多线程并发.html" class="sidebar-link">多线程并发</a></li><li><a href="/test/基础部分/Mysql.html" class="sidebar-link">MySQL</a></li><li><a href="/test/基础部分/Redis.html" class="sidebar-link">Redis</a></li><li><a href="/test/基础部分/源码.html" class="sidebar-link">源码</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架部分</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>大数据</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>项目</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="java-se"><a href="#java-se" class="header-anchor">#</a> Java SE</h1> <h2 id="面向对象基本特性介绍"><a href="#面向对象基本特性介绍" class="header-anchor">#</a> 面向对象基本特性介绍</h2> <p>面向对象 OOP 是基于面向过程而言，面向对象简单来说就是将功能封装到对象（数据和操作结合）里，我们面向对象，让对象去完成这些功能。万物皆对象。</p> <p>三大特性是继承、封装与多态。</p> <h2 id="多态实现原理"><a href="#多态实现原理" class="header-anchor">#</a> 多态实现原理</h2> <p>Java 对于方法调用动态绑定的实现主要依赖于<strong>方法表</strong>，但通过类引用调用(invokevitual)和接口引用调用(invokeinterface)的实现则有所不同。</p> <h3 id="方法表"><a href="#方法表" class="header-anchor">#</a> 方法表</h3> <p>方法表是实现动态调用的核心。上面讲过方法表存放在方法区中的类型信息中。为了优化对象调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表，方法表中的每一个项都是对应方法的指针。
这些方法中包括从父类继承的所有方法以及自身重写（override）的方法。</p> <h2 id="java-基本类型"><a href="#java-基本类型" class="header-anchor">#</a> Java 基本类型</h2> <table><thead><tr><th>基本类型</th> <th>字节</th></tr></thead> <tbody><tr><td>byte</td> <td>1 字节</td></tr> <tr><td>short</td> <td>2 字节</td></tr> <tr><td>int</td> <td>4 字节</td></tr> <tr><td>long</td> <td>8 字节</td></tr> <tr><td>float</td> <td>4 字节</td></tr> <tr><td>double</td> <td>8 字节</td></tr> <tr><td>boolean</td> <td>1 字节或 4 字节（被编译为 int）</td></tr> <tr><td>char</td> <td>2 字节</td></tr></tbody></table> <p>范围：拿 char 举例，char 的范围是[<strong>-2^15-2^15-1</strong>]。</p> <h2 id="jdk、jre-和-jvm"><a href="#jdk、jre-和-jvm" class="header-anchor">#</a> JDK、JRE 和 JVM</h2> <p><img src="/test/assets/img/image-20200212172253575.03137b1a.png" alt="image-20200212172253575"></p> <h2 id="常用包"><a href="#常用包" class="header-anchor">#</a> 常用包</h2> <table><thead><tr><th style="text-align:left;">包名</th> <th style="text-align:left;">说明</th></tr></thead> <tbody><tr><td style="text-align:left;">java.lang</td> <td style="text-align:left;">该包提供了 Java 编程的基础类，例如 Object、Math、String、StringBuffer、System、Thread 等，不使用该包就很难编写 Java 代码了。</td></tr> <tr><td style="text-align:left;">java.util</td> <td style="text-align:left;">该包提供了包含集合框架、遗留的集合类、事件模型、日期和时间实施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组）。</td></tr> <tr><td style="text-align:left;">java.io</td> <td style="text-align:left;">该包通过文件系统、数据流和序列化提供系统的输入与输出。</td></tr> <tr><td style="text-align:left;">java.net</td> <td style="text-align:left;">该包提供实现网络应用与开发的类。</td></tr> <tr><td style="text-align:left;">java.sql</td> <td style="text-align:left;">该包提供了使用 Java 语言访问并处理存储在数据源（通常是一个关系型数据库）中的数据 API。</td></tr> <tr><td style="text-align:left;">java.awt/javax.swing</td> <td style="text-align:left;">这两个包提供了 GUI 设计与开发的类。java.awt 包提供了创建界面和绘制图形图像的所有类，而 javax.swing 包提供了一组“轻量级”的组件，尽量让这些组件在所有平台上的工作方式相同。</td></tr> <tr><td style="text-align:left;">java.text</td> <td style="text-align:left;">提供了与自然语言无关的方式来处理文本、日期、数字和消息的类和接口。</td></tr></tbody></table> <h2 id="重载与重写"><a href="#重载与重写" class="header-anchor">#</a> 重载与重写</h2> <table><thead><tr><th>区别</th> <th>重载方法</th> <th>重写方法</th></tr></thead> <tbody><tr><td>参数列表</td> <td>必须修改</td> <td>一定不能修改</td></tr> <tr><td>返回类型</td> <td>可以修改</td> <td>一定不能修改</td></tr> <tr><td>异常</td> <td>可以修改</td> <td>可以减少或删除，一定不能抛出新的或者更广的异常</td></tr> <tr><td>访问</td> <td>可以修改</td> <td>一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table> <ul><li>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</li> <li>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</li> <li>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li></ul> <h2 id="内存泄漏的场景"><a href="#内存泄漏的场景" class="header-anchor">#</a> 内存泄漏的场景</h2> <p>内存泄露是指不再使用的对象由于仍然被其他对象引用导致垃圾收集器不能及时释放这些对象占用的内存从而造成内存空间浪费的现象。</p> <h3 id="引用类型"><a href="#引用类型" class="header-anchor">#</a> 引用类型</h3> <table><thead><tr><th>级别</th> <th>回收时机</th> <th>用途</th> <th>生存时间</th></tr></thead> <tbody><tr><td>强引用</td> <td>从来不会</td> <td>对象的一般状态</td> <td></td></tr> <tr><td>软引用</td> <td>在内存不足的时候</td> <td>联合 ReferenceQueue 构造有效期短／占内存大／生命周期长的对象的二级高速缓冲器（内存不足时才清空）</td> <td>内存不足时终止</td></tr> <tr><td>弱引用</td> <td>在垃圾回收时</td> <td>联合 ReferenceQueue 构造有效期短／占内存大／生命周期长的对象的一级高速缓冲器（系统发生 GC 则清空）</td> <td>GC 运行后终止</td></tr> <tr><td>虚引用</td> <td>在垃圾回收时</td> <td>联合 ReferenceQueue 来跟踪对象被垃圾回收器回收的活动</td> <td>GC 运行后终止</td></tr></tbody></table> <h3 id="场景"><a href="#场景" class="header-anchor">#</a> 场景</h3> <ul><li><p>使用静态的集合类</p> <p>静态的集合类的生命周期和应用程序的生命周期一样长，所以在程序结束前容器中的对象不能被释放，会造成内存泄露。解决办法是最好不使用静态的集合类，如果使用的话，在不需要容器时要将其赋值为 null。</p></li> <li><p>单例模式可能会造成内存泄漏</p> <p>单例模式只允许应用程序存在一个实例对象，并且这个实例对象的生命周期和应用程序的生命周期一样长，如果单例对象中拥有另一个对象的引用的话，这个被引用的对象就不能被及时回收。解决办法是单例对象中持有的其他对象使用弱引用，弱引用对象在 GC 线程工作时，其占用的内存会被回收掉。</p></li> <li><p>变量不合理的作用域</p> <p>如果变量的定义范围大于使用范围，并且在使用完后没有赋值为 null 的话，会出现内存泄露。定义变量的时候，能定义为局部变量就不要定义为成员变量，或者定义为成员变量的话，在使用完变量后，把变量赋值为 null。</p></li> <li><p>数据库、网络、输入输出流，这些资源没有显示的关闭</p></li> <li><p>使用非静态内部类</p> <p>非静态内部类对象的构建依赖于其外部类，内部类对象会持有外部类对象的 this 引用，即时外部类对象不再被使用了，其占用的内存可能不会被 GC 回收，因为内部类的生命周期可能比外部类的生命周期要长，从而造成外部类对象不能被及时回收。解决办法是尽量使用静态内部类，静态内部类只是形式上在外部类的里面，静态内部类不会持有外部类的引用，可以把静态内部类理解成是一个独立的类，和外部类没什么关系。</p> <blockquote><p>为什么非静态内部类持有对外部类的引用？</p> <p>非静态内部类虽然和外部类写在同一个文件中， 但是编译完成后， 还是生成各自的 class 文件，通过如下三个步骤，内部类对象通过 this 访问外部类对象的成员。</p> <ol><li>编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同，这个成员变量就是指向外部类对象(this)的引用；</li> <li>编译器自动为内部类的构造方法添加一个参数，参数的类型是外部类的类型，在构造方法内部使用这个参数为内部类中添加的成员变量赋值；</li> <li>在调用内部类的构造函数初始化内部类对象时，会默认传入外部类的引用。</li></ol></blockquote></li></ul> <h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="header-anchor">#</a> 序列化与反序列化</h2> <p><strong>序列化</strong>是指将 Java 对象转换为字节序列的过程，而<strong>反序列化</strong>则是将字节序列转换为 Java 对象的过程。</p> <h3 id="实现序列化的好处"><a href="#实现序列化的好处" class="header-anchor">#</a> 实现序列化的好处</h3> <ul><li>实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（如：存储在文件里），实现永久保存对象。</li> <li>利用序列化实现远程通信，即：能够在网络上传输对象。</li></ul> <h3 id="实现原理"><a href="#实现原理" class="header-anchor">#</a> 实现原理</h3> <p>只要对象实现了<strong>Serializable</strong>、Externalizable 接口(该接口仅仅是一个标记接口，并不包含任何方法)，则该对象就实现了序列化。</p> <h4 id="序列化"><a href="#序列化" class="header-anchor">#</a> 序列化</h4> <p>序列化，首先要创建某些 OutputStream 对象，然后将其封装在一个 ObjectOutputStream 对象内，这时调用 writeObject()方法，即可将对象序列化，并将其发送给 OutputStream（对象序列化是基于字节的，因此使用的 InputStream 和 OutputStream 继承的类）。</p> <h4 id="反序列化"><a href="#反序列化" class="header-anchor">#</a> 反序列化</h4> <p>反序列化，即反向进行序列化的过程，需要将一个 InputStream 封装在 ObjectInputStream 对象内，然后调用 readObject()方法，获得一个对象引用（它是指向一个向上转型的 Object），然后进行类型强制转换来得到该对象。</p> <h3 id="序列化-反序列化失败场景"><a href="#序列化-反序列化失败场景" class="header-anchor">#</a> 序列化/反序列化失败场景</h3> <ul><li><p>声明为 static 和 transient 类型的成员变量不能被序列化</p></li> <li><p>serialVersionUID 与对应的发送者的类的版本号不同不能被反序列化</p> <p>如果序列化的类未显式的声明 serialVersionUID，则序列化运行时将基于该类的各个方面计算该类的默认 serialVersionUID 值，如“Java(TM) 对象序列化规范”中所述。不过，强烈建议 所有可序列化类都显式声明 serialVersionUID 值，原因是计算默认的 serialVersionUID 对类的详细信息具有较高的敏感性，根据编译器实现的不同可能千差万别，这样在反序列化过程中可能会导致意外的 InvalidClassException。</p></li></ul> <h2 id="访问权限"><a href="#访问权限" class="header-anchor">#</a> 访问权限</h2> <table><thead><tr><th>访问权限</th> <th>本类</th> <th>本包的类</th> <th>子类</th> <th>非子类的外包类</th></tr></thead> <tbody><tr><td>public</td> <td>是</td> <td>是</td> <td>是</td> <td>是</td></tr> <tr><td>protected</td> <td>是</td> <td>是</td> <td>是</td> <td>否</td></tr> <tr><td>default</td> <td>是</td> <td>是</td> <td>否</td> <td>否</td></tr> <tr><td>private</td> <td>是</td> <td>否</td> <td>否</td> <td>否</td></tr></tbody></table> <h2 id="与-的区别"><a href="#与-的区别" class="header-anchor">#</a> &amp;与&amp;&amp;的区别</h2> <p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。</p> <p>&amp;的逻辑与和&amp;&amp;的短路与分别都是表示左边和右边都为 true，结果才为 true，但是使用短路与时，如果&amp;&amp;左边为 false，那么整个值就直接判断为 false，不会进行右边的逻辑操作。</p> <h2 id="array-和-arraylist-的区别"><a href="#array-和-arraylist-的区别" class="header-anchor">#</a> Array 和 ArrayList 的区别</h2> <ul><li><p>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型；</p></li> <li><p>Array 大小固定，ArrayList 是动态变化的；</p></li> <li><p>ArrayList 有更多的特性，如 addAll()，removeAll()，iterator()等等。</p></li></ul> <h2 id="comparable-和-comparator-接口的作用以及区别"><a href="#comparable-和-comparator-接口的作用以及区别" class="header-anchor">#</a> Comparable 和 Comparator 接口的作用以及区别</h2> <ul><li><p>Comparable：只有 compareTo()；</p></li> <li><p>Comparator：包含 compare()+equals()。</p></li></ul> <h2 id="collection-和-collections-的区别"><a href="#collection-和-collections-的区别" class="header-anchor">#</a> Collection 和 Collections 的区别</h2> <ul><li>Collection：集合类的上级接口，继承与他的接口主要有 Set 和 List；</li> <li>Collections：针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</li></ul> <h2 id="快速失败-fail-fast-和安全失败-fail-safe-的区别"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别" class="header-anchor">#</a> 快速失败(fail-fast)和安全失败(fail-safe)的区别</h2> <ul><li><p>fail-fast：java.util 包下面的所有的集合类都是快速失败的，快速失败的迭代器会抛出 ConcurrentModificationException 异常，具体底层是因为 remove 方法时，expectedModCount 不等于 modCount：</p> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>当用集合的方法进行 add、remove、clear 操作时，modCount 就会发生改变，但是使用 Iterator 接口的 remove()方法是不会改变的。</p></li> <li><p>fail-safe：java.util.concurrent 包下面的所有的类都是安全失败的，安全失败是基于对底层集合做拷贝，因此不会抛出异常。</p></li></ul> <h2 id="值传递和引用传递"><a href="#值传递和引用传递" class="header-anchor">#</a> 值传递和引用传递</h2> <ul><li>值传递是对基本变量而言的，传递的是变量的副本，改变副本不改变原值。</li> <li>引用传递是对于对象型变量而言的，传递的是对象的副本，对引用对象进行操作会改变源对象。</li></ul> <p>java 中大部分都是<strong>值传递</strong>，包括引用对象，所谓的值传递个人理解是，传递了一个栈帧的拷贝，并且与源栈帧指向相同的句柄或者堆实例对象内存地址，以下是他人总结：</p> <ol><li><p>如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。</p></li> <li><p>如果是对引用类型的数据进行操作，形参和实参保持指向同一个对象地址，引用不改变下，形参的操作，会影响实参指向的对象的内容。</p></li></ol> <p><strong>==和 equals 的区别：</strong></p> <ul><li>==如果是基本类型比较的是值是否相等，如果是引用类型比较的是指向的内存地址是否相等。</li> <li>equals 如果没有重写比较的是地址是否相等，重写了可以比较值是否相等。</li></ul> <h2 id="double-类型的比较"><a href="#double-类型的比较" class="header-anchor">#</a> Double 类型的比较</h2> <p>因为二进制的<strong>小数</strong>无法精确表达 10 进制小数，所以直接使用 double==判断会产生误差，需要使用 new BigDecimal(value.toString)转成 BigDecimal 对象进行比较。</p> <p>BigDecimal 原理：把十进制小数扩大 N 倍让它在<strong>整数</strong>的维度上进行计算，并保留相应的精度信息。scale 记录精度信息，intCompact 记录被放大的整数信息。</p> <h2 id="equals-与-hashcode"><a href="#equals-与-hashcode" class="header-anchor">#</a> equals 与 hashCode</h2> <p>若是对象，需要同时重写这两者，两者重写与不重写如下所示：</p> <table><thead><tr><th></th> <th>不重写</th> <th>重写</th></tr></thead> <tbody><tr><td>hashCode</td> <td>比较内存地址，具体 jvm 可能不同</td> <td>自定义逻辑</td></tr> <tr><td>equals</td> <td>比较内存地址</td> <td>自定义逻辑</td></tr></tbody></table> <p>Java 对象的 eqauls 方法和 hashCode 方法是这样规定的：</p> <ol><li>相等（相同）的对象必须具有相等的哈希码（或者散列码）；</li> <li>如果两个对象的 hashCode 相同，它们并不一定相同。</li></ol> <h2 id="arraylist-与-linkedlist-的区别"><a href="#arraylist-与-linkedlist-的区别" class="header-anchor">#</a> ArrayList 与 LinkedList 的区别</h2> <ul><li><p>数据结构不同</p> <p>ArrayList 底层是 Object 数组，而 LinkedList 底层维护了 Node 类型的链表。</p></li> <li><p>效率不同</p> <p>查找元素时，ArrayList 获取元素为 O(1)，LinkedList 为 O(n)；当对数据的中间部分进行增加和删除时，LinkedList 效率更高。ArrayList 会使用 System.arraycopy()进行数据迁移操作。</p></li></ul> <h2 id="异常体系"><a href="#异常体系" class="header-anchor">#</a> 异常体系</h2> <p><img src="/test/assets/img/image-20200302134849364.8f939e0b.png" alt="image-20200302134849364"></p> <h2 id="反射"><a href="#反射" class="header-anchor">#</a> 反射</h2> <p>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p> <h3 id="工作原理"><a href="#工作原理" class="header-anchor">#</a> 工作原理</h3> <p>在类加载的加载阶段，类加载器会根据类的全限定名读取二进制字节流到 JVM 的内部，并存储在元空间，在将其转换为目标类型对应的 java 实例，而反射就是在这一阶段读取对应的 class 文件从而获取相应的信息。</p> <h3 id="工作流程"><a href="#工作流程" class="header-anchor">#</a> 工作流程</h3> <p>首先通过.forName()获取目标对象，通过目标对象的 getDeclaredField()方法获取字段（Field）对象，然后再通过字段对象的 setAccessible(true)将其设置为可以访问，接下来就可以通过 get/set 方法来获取/设置字段的值了。</p> <p>获取类：</p> <ol><li>.forName(全限定名)</li> <li>类名.class</li> <li>对象.getClass()</li></ol> <p>获取内容：</p> <ol><li>getDeclaredMethods()</li> <li>getDeclaredFields()</li> <li>getDeclaredConstructors()</li></ol> <p>使用：</p> <ol><li>方法.invoke(参数)</li> <li>构造方法.newInstance()</li> <li>类对象.newInstance()</li></ol> <h2 id="内部类"><a href="#内部类" class="header-anchor">#</a> 内部类</h2> <p>内部类分为成员内部类，静态内部类，局部内部类和匿名内部类。</p> <p>成员内部类特点：</p> <ol><li>不允许有静态变量或方法；</li> <li>依附外部类，只有创建外部类才能创建内部类。</li></ol> <p>静态内部类特点：</p> <ol><li>不依赖外部类；</li> <li>不可以使用任何外部类的非 static 属性或方法。</li></ol> <p>局部内部类特点：</p> <ol><li>类不允许使用访问权限修饰符；</li> <li>除了方法，完全隐藏；</li> <li>方法形参必须是 final。</li></ol> <p>匿名内部类特点：</p> <ol><li>必须继承一个抽象类或者一个接口；</li> <li>没有构造方法；</li> <li>方法形参必须为 final。</li></ol> <p>所有内部类均可访问可访问的外部类属性和方法，外部类可以通过创建内部类实例来间接访问内部类。</p> <h3 id="为什么需要-final"><a href="#为什么需要-final" class="header-anchor">#</a> 为什么需要 final</h3> <ul><li><p>类的生命周期</p> <p>由于内部类不会随着外部类毁灭而毁灭，因此为了保证数据不会引用到空对象，所以需要拷贝一份参数。</p></li> <li><p>数据一致性</p> <p>为了实现数据一致性，防止原先的局部变量发生改变以至于内部类得不到通知，使程序结果与预期不同，所以需要 final 修饰访问的参数。</p></li></ul> <h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="header-anchor">#</a> 抽象类和接口的区别</h2> <table><thead><tr><th></th> <th>抽象类</th> <th>接口</th></tr></thead> <tbody><tr><td>是否有非抽象方法</td> <td>可以有非抽象方法</td> <td>全是抽象方法</td></tr> <tr><td>是否有构造方法</td> <td>有</td> <td>没有</td></tr> <tr><td>是否有普通成员变量</td> <td>有</td> <td>没有</td></tr> <tr><td>访问权限</td> <td>没有限制</td> <td>必须是 public 权限</td></tr> <tr><td>是否有静态方法和静态代码块</td> <td>有</td> <td>没有(java8 有)</td></tr> <tr><td>方法参数类型</td> <td>没有限制</td> <td>必须是 static final</td></tr> <tr><td>继承/实现</td> <td>单继承</td> <td>可以多实现</td></tr> <tr><td>抽象目标</td> <td>对类抽象</td> <td>对行为抽象</td></tr> <tr><td>设计思想</td> <td>模板式设计</td> <td>辐射式设计</td></tr></tbody></table> <h2 id="泛型"><a href="#泛型" class="header-anchor">#</a> 泛型</h2> <p>泛型即参数化类型，是编译器的概念。(Array 不支持泛型)</p> <h3 id="使用泛型的好处"><a href="#使用泛型的好处" class="header-anchor">#</a> 使用泛型的好处</h3> <ol><li>类型安全，防止出现 ClassCastException 异常；</li> <li>消除强制转换。</li></ol> <h3 id="类型擦除"><a href="#类型擦除" class="header-anchor">#</a> 类型擦除</h3> <p>当编译器对带有泛型的 java 代码进行编译时，它会去执行类型检查和类型推断，然后生成普通的不带泛型的字节码，这种普通的字节码可以被一般的 Java 虚拟机接收并执行，这就叫做<strong>类型擦除</strong>。</p> <h3 id="限定通配符与非限定通配符"><a href="#限定通配符与非限定通配符" class="header-anchor">#</a> 限定通配符与非限定通配符</h3> <p>限定通配符对类型进行了限制。有两种限定通配符，一种是<code>&lt;? extends T&gt;</code>它通过确保类型必须是 T 的子类来设定类型的<strong>上界</strong>，另一种是<code>&lt;? super T&gt;</code>它通过确保类型必须是 T 的父类来设定类型的<strong>下界</strong>。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。</p> <p>另一方面<code>&lt;?&gt;</code>表 示了非限定通配符，因为<code>&lt;?&gt;</code>可以用任意类型来替代。</p> <h3 id="list-和-list-object-的区别"><a href="#list-和-list-object-的区别" class="header-anchor">#</a> List&lt;?&gt;和 List&lt;Object&gt;的区别</h3> <p>List&lt;?&gt; 是一个未知类型的 List，而 List&lt;Object&gt; 其实是任意类型的 List。你可以把 List&lt;String&gt;, List&lt;Integer&gt;赋值给 List&lt;?&gt;，却不能把 List&lt;String&gt;赋值给 List&lt;Object&gt;。</p> <h2 id="注解"><a href="#注解" class="header-anchor">#</a> 注解</h2> <p>注解通过 @interface 关键字进行定义，简单理解就是贴标签。</p> <h3 id="元注解"><a href="#元注解" class="header-anchor">#</a> 元注解</h3> <p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。其实就是普通注解的描述。</p> <h4 id="retention"><a href="#retention" class="header-anchor">#</a> @Retention</h4> <p>规定注解的存活时间，具体值如下：</p> <ul><li><p>RetentionPolicy.SOURCE</p> <p>注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。</p></li> <li><p>RetentionPolicy.CLASS</p> <p>注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。</p></li> <li><p>RetentionPolicy.RUNTIME</p> <p>注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。</p></li></ul> <h4 id="documented"><a href="#documented" class="header-anchor">#</a> @Documented</h4> <p>它的作用是能够将注解中的元素包含到 Javadoc 中去。</p> <h4 id="target"><a href="#target" class="header-anchor">#</a> @Target</h4> <p>@Target 指定了注解运用的地方，即限定使用场景，具体值如下：</p> <ul><li><p>ElementType.ANNOTATION_TYPE</p> <p>可以给一个注解进行注解。</p></li> <li><p>ElementType.CONSTRUCTOR</p> <p>可以给构造方法进行注解。</p></li> <li><p>ElementType.FIELD</p> <p>可以给属性进行注解。</p></li> <li><p>ElementType.LOCAL_VARIABLE</p> <p>可以给局部变量进行注解。</p></li> <li><p>ElementType.METHOD</p> <p>可以给方法进行注解。</p></li> <li><p>ElementType.PACKAGE</p> <p>可以给一个包进行注解。</p></li> <li><p>ElementType.PARAMETER</p> <p>可以给一个方法内的参数进行注解。</p></li> <li><p>ElementType.TYPE</p> <p>可以给一个类型进行注解，比如类、接口、枚举。</p></li></ul> <h4 id="inherited"><a href="#inherited" class="header-anchor">#</a> @Inherited</h4> <p>如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。</p> <h4 id="repeatable"><a href="#repeatable" class="header-anchor">#</a> @Repeatable</h4> <p>这个注解可以有多个不同的属性。</p> <h3 id="注解的属性"><a href="#注解的属性" class="header-anchor">#</a> 注解的属性</h3> <p>注解的属性也叫做成员变量，注解只有成员变量，没有方法。如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">TestAnnotation</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">msg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">&quot;Hi&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其中，default 是为属性赋予默认值。使用方式如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 有默认值</span>
<span class="token annotation punctuation">@TestAnnotation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token comment">// 没有默认值</span>
<span class="token annotation punctuation">@TestAnnotation</span><span class="token punctuation">(</span>id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>msg<span class="token operator">=</span><span class="token string">'Hi'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token comment">// 只有一个id属性</span>
<span class="token annotation punctuation">@TestAnnotation</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token comment">// 没有任何属性</span>
<span class="token annotation punctuation">@TestAnnotation</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre></div><h3 id="java-预置的注解"><a href="#java-预置的注解" class="header-anchor">#</a> Java 预置的注解</h3> <ul><li><p>@Deprecated</p> <p>告诉开发者，这是一个过时的元素。</p></li> <li><p>@Override</p> <p>要重写的方法。</p></li> <li><p>@SuppressWarnings</p> <p>忽略被编译器提醒的警告。</p></li> <li><p>@SafeVarargs</p> <p>参数安全类型注解。提醒开发者不要用参数做一些不安全的操作,它的存在会阻止编译器产生 unchecked 这样的警告。</p></li> <li><p>@FunctionalInterface</p> <p>函数式接口注解，所谓的函数式编程是 Java8 引入的概念，它是仅有一个方法的普通接口。</p></li></ul> <h3 id="如何使用"><a href="#如何使用" class="header-anchor">#</a> 如何使用</h3> <ol><li>使用 AOP 进行对特定注解的拦截，执行自己的处理逻辑。如限流、打印日志、报告异常等。</li> <li>使用反射，对特定注解进行拦截，执行相应的处理操作。</li></ol> <h2 id="io"><a href="#io" class="header-anchor">#</a> IO</h2> <p>数据在两设备间的传输称为流。流的本质是数据传输,根据数据传输特性将流抽象为各种类,方便更直观的进行数据操作。</p> <h3 id="分类"><a href="#分类" class="header-anchor">#</a> 分类</h3> <p><strong>按操作对象来分：</strong></p> <ol><li><p>文件（file）：FileInputStream、FileOutputStream、FileReader、FileWriter</p></li> <li><p>数组（[]）：</p> <ul><li>2.1、字节数组（byte[]）：ByteArrayInputStream、ByteArrayOutputStream</li> <li>2.2、字符数组（char[]）：CharArrayReader、CharArrayWriter</li></ul></li> <li><p>管道操作：PipedInputStream、PipedOutputStream、PipedReader、PipedWriter</p></li> <li><p>基本数据类型：DataInputStream、DataOutputStream</p></li> <li><p>缓冲操作：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter</p></li> <li><p>打印：PrintStream、PrintWriter</p></li> <li><p>对象序列化反序列化：ObjectInputStream、ObjectOutputStream</p></li> <li><p>转换：InputStreamReader、OutputStreWriter</p></li></ol> <p><strong>从运输方式角度来分：</strong></p> <ol><li>字节流</li> <li>字符流</li></ol> <p>字节流用来处理二进制文件（图片、MP3、视频文件），字符流用来处理文本文件。字节流继承 inputStream 和 OutputStream,字符流继承自 Reader 和 Writer。</p> <p><img src="/test/assets/img/image-20200217181944339.1000f779.png" alt="image-20200217181944339"></p> <h3 id="字节流和字符流的区别"><a href="#字节流和字符流的区别" class="header-anchor">#</a> 字节流和字符流的区别</h3> <table><thead><tr><th></th> <th>字节流</th> <th>字符流</th></tr></thead> <tbody><tr><td>是否用到缓冲区（内存）</td> <td>不用</td> <td>需要</td></tr> <tr><td>操作对象</td> <td>任何类型，包括二进制</td> <td>只能处理字符或者字符串</td></tr> <tr><td>祖先</td> <td>InputStream/OutputStream</td> <td>Reader/Writer</td></tr> <tr><td>使用场景</td> <td>大部分情况</td> <td>频繁对字符操作</td></tr></tbody></table> <h3 id="randomaccessfile"><a href="#randomaccessfile" class="header-anchor">#</a> RandomAccessFile</h3> <p>它在 java.io 包中是一个特殊的类，既不是输入流也不是输出流，它两者都可以做到。他是 Object 的直接子类。通常来说，一个流只有一个功能，要么读，要么写。但是 RandomAccessFile<strong>既可以读文件，也可以写文件</strong>。</p> <h3 id="system-out-println"><a href="#system-out-println" class="header-anchor">#</a> System.out.println</h3> <p>println 是 PrintStream 的一个方法。out 是一个静态 PrintStream 类型的成员变量，System 是一个 java.lang 包中的类，用于和底层的操作系统进行交互。</p> <h3 id="缓冲区"><a href="#缓冲区" class="header-anchor">#</a> 缓冲区</h3> <ol><li>缓冲区就是一段特殊的内存区域，很多情况下当程序需要频繁地操作一个资源（如文件或数据库）则性能会很低，所以为了提升性能就可以将一部分数据暂时读写到缓存区，以后直接从此区域中读写数据即可，这样就显著提升了性。</li> <li>对于 Java 字符流的操作都是在缓冲区操作的，所以如果我们想在字符流操作中主动将缓冲区刷新到文件则可以使用 flush() 方法操作。</li></ol> <h3 id="printstream、bufferedwriter、printwriter"><a href="#printstream、bufferedwriter、printwriter" class="header-anchor">#</a> PrintStream、BufferedWriter、PrintWriter</h3> <ul><li><p>PrintStream</p> <p>输出功能非常强大，通常如果需要输出文本内容，都应该将输出流包装成 PrintStream 后进行输出。用来处理字节流。</p></li> <li><p>BufferedWriter</p> <p>将文本写入字符输出流，缓冲各个字符从而提供单个字符，数组和字符串的高效写入。通过 write()方法可以将获取到的字符输出，然后通过 <strong>newLine()</strong> 进行换行操作。BufferedWriter 中的字符流必须通过调用 flush 方法才能将其刷出去。并且 BufferedWriter 只能对字符流进行操作。如果要对字节流操作，则使用 BufferedInputStream。</p></li> <li><p>PrintWriter</p> <p>与 PrintStream 相似，用于处理字符流。</p></li></ul> <h3 id="节点流与处理流"><a href="#节点流与处理流" class="header-anchor">#</a> 节点流与处理流</h3> <ul><li><p>节点流</p> <p>直接与数据源相连，用于输入或者输出。</p></li> <li><p>处理流</p> <p>在节点流的基础上对之进行加工，进行一些功能的扩展。</p></li></ul> <p>处理流的构造器必须要传入节点流的子类。</p> <p><img src="/test/assets/img/image-20200217183940566.e3bd16be.png" alt="image-20200217183940566"></p> <h3 id="流的关闭操作"><a href="#流的关闭操作" class="header-anchor">#</a> 流的关闭操作</h3> <ol><li>流一旦打开就必须关闭，使用 close 方法。</li> <li>放入 finally 语句块中（finally 语句一定会执行）。</li> <li>调用处理流后就关闭处理流。</li> <li>多个流互相调用只关闭最外层的流。</li></ol> <h2 id="java8-新特性"><a href="#java8-新特性" class="header-anchor">#</a> Java8 新特性</h2> <ol><li><p>Lambda 表达式——允许把函数作为方法的参数；</p></li> <li><p>方法引用——直接引用已有的 Java 类或对象的方法或构造器；</p></li> <li><p>默认方法——接口里面有一个默认实现方法；</p></li> <li><p>新工具——新的编译工具，如：Nashorn 引擎 jjs、 类依赖分析器 jdeps；</p></li> <li><p>Stream API——函数式编程；</p></li> <li><p>Date Time API——加强对日期与时间的处理；</p></li> <li><p>Optional 类——解决空指针异常；</p></li> <li><p>Nashorn, JavaScript 引擎—— Java 8 提供了一个新的 Nashorn javascript 引擎，它允许我们在 JVM 上运行特定的 javascript 应用。</p></li></ol> <h3 id="lambda-表达式"><a href="#lambda-表达式" class="header-anchor">#</a> Lambda 表达式</h3> <p>例子：<code>new Thread(() -&gt; System.out.println(&quot;thread&quot;));</code></p> <p>（）是接口方法的括号，当有多个抽象方法就不能表示了，所以函数型接口是支持只有一个抽象方法的接口。</p> <p><strong>表达式特征：</strong></p> <ul><li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li> <li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li> <li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li> <li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li></ul> <p><strong>方法引用：</strong></p> <ol><li><p><strong>对象::实例方法</strong>，将 lambda 的参数当做方法的参数使用：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> sc <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">;</span>
<span class="token comment">//等效</span>
<span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> sc2 <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
sc<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">&quot;hey&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><strong>类::静态方法</strong>，将 lambda 的参数当做方法的参数使用：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> sf <span class="token operator">=</span> <span class="token class-name">String</span><span class="token operator">::</span><span class="token function">valueOf</span><span class="token punctuation">;</span>
<span class="token comment">//等效</span>
<span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> sf2 <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> apply1 <span class="token operator">=</span> sf<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p><strong>类::实例方法</strong>，将 lambda 的第一个参数当做方法的调用者，其他的参数作为方法的参数。开发中尽量少些此类写法，减少后续维护成本：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">BiPredicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> sbp <span class="token operator">=</span> <span class="token class-name">String</span><span class="token operator">::</span><span class="token function">equals</span><span class="token punctuation">;</span>
<span class="token comment">//等效</span>
<span class="token class-name">BiPredicate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> sbp2 <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> test <span class="token operator">=</span> sbp<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ol> <p><strong>构造引用：</strong></p> <ol><li><p>无参的构造方法是类::实例方法模型：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> us <span class="token operator">=</span> <span class="token class-name">User</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">;</span>
<span class="token comment">//等效</span>
<span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> us2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//获取对象</span>
<span class="token class-name">User</span> user <span class="token operator">=</span> us<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>有参的构造方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//一个参数,参数类型不同则会编译出错</span>
<span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> uf <span class="token operator">=</span> id <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//或加括号</span>
<span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> uf2 <span class="token operator">=</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//等效</span>
<span class="token class-name">Function</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> uf3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">User</span> apply <span class="token operator">=</span> uf<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">61888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//两个参数</span>
<span class="token class-name">BiFunction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> ubf <span class="token operator">=</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">User</span> happy <span class="token operator">=</span> ubf<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">618</span><span class="token punctuation">,</span> <span class="token string">&quot;狂欢happy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ol> <h3 id="接口的默认方法"><a href="#接口的默认方法" class="header-anchor">#</a> 接口的默认方法</h3> <p>实际的例子有 List 接口的 sort 方法，它是一个默认方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token comment">// ...其他成员</span>

    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>三条规则：</strong></p> <ol><li><strong>类中的方法</strong>优先级最高，类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。</li> <li>如果第一条无法判断，那么<strong>子接口的优先级更高</strong>：方法签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果 B 继承了 A，那么 B 就比 A 更加具体。</li> <li>最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法，显式地选择使用哪一个默认方法的实现。</li></ol> <h3 id="localdatetime"><a href="#localdatetime" class="header-anchor">#</a> LocalDateTime</h3> <h4 id="localdate"><a href="#localdate" class="header-anchor">#</a> LocalDate</h4> <ol><li><p>创建：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//获取当前年月日</span>
<span class="token class-name">LocalDate</span> localDate <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//构造指定的年月日</span>
<span class="token class-name">LocalDate</span> localDate2 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>获取年、月、日、星期：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> year <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> year1 <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">ChronoField</span><span class="token punctuation">.</span>YEAR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Month</span> month <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> month1 <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">ChronoField</span><span class="token punctuation">.</span>MONTH_OF_YEAR<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> day <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">getDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> day1 <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">ChronoField</span><span class="token punctuation">.</span>DAY_OF_MONTH<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">DayOfWeek</span> dayOfWeek <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">getDayOfWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> dayOfWeek1 <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">ChronoField</span><span class="token punctuation">.</span>DAY_OF_WEEK<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ol> <h4 id="localtime"><a href="#localtime" class="header-anchor">#</a> LocalTime</h4> <p>创建和获取与 LocalDate 相似，不再赘述。</p> <h4 id="localdatetime-2"><a href="#localdatetime-2" class="header-anchor">#</a> LocalDateTime</h4> <p>创建和获取与 LocalDate 相似，不再赘述。</p> <h4 id="格式化"><a href="#格式化" class="header-anchor">#</a> 格式化</h4> <ol><li><p>LocalDate 转 String：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">LocalDate</span> localDate <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// BASIC_ISO_DATE yyyyMMdd</span>
<span class="token class-name">String</span> s1 <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span>BASIC_ISO_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ISO_LOCAL_DATE yyyy-MM-dd</span>
<span class="token class-name">String</span> s2 <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span>ISO_LOCAL_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 自定义</span>
<span class="token class-name">DateTimeFormatter</span> dateTimeFormatter <span class="token operator">=</span> <span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">&quot;dd/MM/yyyy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s3 <span class="token operator">=</span> localDate<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>dateTimeFormatter<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>String 转 LocalDate：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> date <span class="token operator">=</span> <span class="token string">&quot;20200212&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 自定义</span>
<span class="token class-name">DateTimeFormatter</span> dateTimeFormatter <span class="token operator">=</span> <span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">&quot;yyyyMMdd&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">LocalDate</span> localDate <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> <span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span>BASIC_ISO_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">LocalDate</span> localDate2 <span class="token operator">=</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>date<span class="token punctuation">,</span> dateTimeFormatter<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ol> <h3 id="optional-类"><a href="#optional-类" class="header-anchor">#</a> Optional 类</h3> <p>Optional 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</p> <p>常用方法：</p> <ul><li>Optional.of(T t) : 创建一个 Optional 实例；</li> <li>Optional.empty() : 创建一个空的 Optional 实例；</li> <li>Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例；</li> <li>isPresent() : 判断是否包含值；</li> <li>get()：如果调用对象包含值，返回该值，否则抛出异常；</li> <li>orElse(T t) : 如果调用对象包含值，返回该值，否则返回 t；</li> <li>orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值；</li> <li>map(Function f): 如果有值对其处理，并返回处理后的 Optional，否则返回 Optional.empty()；</li> <li>flatMap(Function mapper):与 map 类似，要求返回值必须是 Optional。</li></ul> <h3 id="stream-api"><a href="#stream-api" class="header-anchor">#</a> Stream API</h3> <p>Stream 是 Java8 的新特性之一，从名字看出来，它的含义是流，所谓的流就是一个数据渠道，可以用于操作集合所生成的元素序列。 实际上不光是集合，包括数组、文件等，只要是可以转换成流，我们都可以借助流式处理，类似于我们写 SQL 语句一样对其进行操作。</p> <p><strong>特点：</strong></p> <ol><li>Stream 自己不会存储元素。</li> <li>Stream 不会改变源对象。</li> <li>Stream 操作是延时执行的，这意味着它们会等到需要结果时才执行。</li></ol> <p><strong>流式处理：</strong></p> <p>Stream 的流式处理可以分为三个部分：转换成流、中间操作、终端操作，具体例子：</p> <p><code>List userIds = userLists.stream().map(UserDO::getId).collect(Collectors.toList());</code></p> <p>stream 语句将 userLists 集合转换成了一个流，map 为中间操作，通过函数式表达式获取 user 的 Id，最后通过终端操作将其转换成一个 list 集合返回。</p> <p>创建流的方式：</p> <ol><li>.stream()/.parallelStream()；</li> <li>Arrays.stream()；</li> <li>Steam.of(&quot;123&quot;,&quot;456&quot;)；</li></ol> <p>中间操作与结束操作：</p> <p><img src="/test/assets/img/image-20200212211912365.292cc62b.png" alt="image-20200212211912365"></p> <p><strong>流水线原理：</strong></p> <ul><li>操作的记录</li></ul> <p>注意，这里的操作是指中间操作，Stream 中会使用 Stage 概念来描述一个完整的操作，并用某种实例化后的 PipelineHelper 来代表 Stage，将具有先后顺序的各个 Stage 连到一起，就构成了整个流水线，其中 Stream 相关类和接口的继承关系如上图所示。</p> <p>Stream 流水线组织结构示意图如下：</p> <p><img src="/test/assets/img/image-20200212214032084.69f1ad69.png" alt="image-20200212214032084"></p> <p>通过 Collection.stream()方法得到 Head，也就是 stage0，紧接着调用一系列中间操作，不断产生新的 Stream，这些 Stream 对象以双向链表的形式组织在一起，构成整个流水线，由于每个 Stage 都记录了前一个 Stage 和本次的操作以及回调函数，依靠这种结构就能建立起对数据源的所有操作。</p> <ul><li>操作的叠加</li></ul> <p>现在我们知道 Stream()是如何记录每一步的操作了，要想让流水线将所有的操作叠加在一起，还需要有一种协议来协调相邻的 Stage 之间的关系。这个协议就是 Sink 接口，Sink 接口方法如下：</p> <p><img src="/test/assets/img/image-20200212214312111.b4087826.png" alt="image-20200212214312111"></p> <p>有了此协议，相邻 Stage 之间调用就很方便了，每个 Stage 都会将自己的操作封装到一个 Sink 里，前一个 Stage 只需调用后一个 Stage 的 accept()方法即可，并不需要知道内部是如何处理的。对于短路操作，也要实现 cancellationRequested()。<strong>实际上 Stream API 内部实现的本质，就是如何重载 Sink 的这四个接口方法。</strong></p> <ul><li>执行结果的存放</li></ul> <p><img src="/test/assets/img/image-20200212214438029.9bc930a2.png" alt="image-20200212214438029"></p> <ol><li><p>对于表中返回 boolean 或者 Optional 的操作（Optional 是存放 一个 值的容器）的操作，由于值返回一个值，只需要在对应的 Sink 中记录这个值，等到执行结束时返回就可以了。</p></li> <li><p>对于归约操作，最终结果放在用户调用时指定的容器中（容器类型通过收集器指定）。collect(), reduce(), max(), min()都是归约操作，虽然 max()和 min()也是返回一个 Optional，但事实上底层是通过调用 reduce()方法实现的。</p></li> <li><p>对于返回是数组的情况，毫无疑问的结果会放在数组当中。这么说当然是对的，但在最终返回数组之前，结果其实是存储在一种叫做 Node 的数据结构中的。Node 是一种多叉树结构，元素存储在树的叶子当中，并且一个叶子节点可以存放多个元素。这样做是为了并行执行方便。</p></li></ol> <h3 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h3> <ol><li><p>HashMap 前后变化</p> <p>链表长度大于 8 时采取红黑树的结构存储。</p></li> <li><p>ConcurrentHashMap</p> <p>从分段锁改为 CAS+Synchronized。</p></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/test/基础部分/计算机网络.html" class="prev">
        计算机网络
      </a></span> <span class="next"><a href="/test/基础部分/JVM.html">
        JVM
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/test/assets/js/app.fb04842c.js" defer></script><script src="/test/assets/js/2.275389a7.js" defer></script><script src="/test/assets/js/4.a42ed78f.js" defer></script>
  </body>
</html>
